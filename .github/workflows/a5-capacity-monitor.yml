name: A5-Reserve Capacity Monitor

on:
  schedule:
    # Run every 30 minutes during business hours (Mon-Fri 9AM-6PM JST)
    - cron: '*/30 0-9 * * 1-5'  # 9AM-6PM JST = 0-9 UTC
  workflow_dispatch:  # Allow manual trigger
  issues:
    types: [opened, closed, labeled, unlabeled]  # Trigger on issue state changes

permissions:
  issues: write
  contents: read

jobs:
  calculate-capacity:
    runs-on: ubuntu-latest
    name: Calculate A5-Reserve Team Capacity

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Calculate capacity and update labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Configuration
            const TEAM_MEMBERS = 3;  // A5-Reserve team size
            const WEEKLY_HOURS = 40; // Hours per team member per week
            const TOTAL_CAPACITY = TEAM_MEMBERS * WEEKLY_HOURS; // 120 hours

            // Complexity weights
            const COMPLEXITY_WEIGHTS = {
              'P0': 20,
              'P1': 10,
              'P2': 5,
              'P3': 2
            };

            // Capacity thresholds
            const THRESHOLD_LIMITED = 70;  // 70-90% = Limited
            const THRESHOLD_FULL = 90;     // 90%+ = Full

            console.log('üîç Fetching active A5-Reserve tasks...');

            // Fetch all active issues assigned to A5-Reserve
            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'üë• team:a5-reserve',
              per_page: 100
            });

            console.log(`Found ${issues.length} total A5-Reserve issues`);

            // Filter for active tasks (implementing or reviewing)
            const activeTasks = issues.filter(issue => {
              const labels = issue.labels.map(l => l.name);
              return labels.some(l =>
                l === 'üèóÔ∏è state:implementing' ||
                l === 'üëÄ state:reviewing' ||
                l === 'üéØ reserve:accepted' ||
                l === '‚è≥ reserve:queued'
              );
            });

            console.log(`Active tasks: ${activeTasks.length}`);

            // Calculate complexity points
            let totalPoints = 0;
            const taskBreakdown = {
              P0: 0,
              P1: 0,
              P2: 0,
              P3: 0
            };

            activeTasks.forEach(issue => {
              const labels = issue.labels.map(l => l.name);
              let priority = 'P3'; // Default

              // Determine priority
              if (labels.some(l => l.includes('priority:P0'))) priority = 'P0';
              else if (labels.some(l => l.includes('priority:P1'))) priority = 'P1';
              else if (labels.some(l => l.includes('priority:P2'))) priority = 'P2';
              else if (labels.some(l => l.includes('priority:P3'))) priority = 'P3';

              const points = COMPLEXITY_WEIGHTS[priority];
              totalPoints += points;
              taskBreakdown[priority]++;

              console.log(`  #${issue.number}: ${priority} = ${points} points`);
            });

            // Calculate capacity percentage
            const capacityPercentage = Math.round((totalPoints / TOTAL_CAPACITY) * 100);

            console.log('\nüìä Capacity Calculation:');
            console.log(`  Total Points: ${totalPoints}`);
            console.log(`  Total Capacity: ${TOTAL_CAPACITY}`);
            console.log(`  Capacity: ${capacityPercentage}%`);
            console.log(`  Task Breakdown: P0:${taskBreakdown.P0}, P1:${taskBreakdown.P1}, P2:${taskBreakdown.P2}, P3:${taskBreakdown.P3}`);

            // Determine capacity level
            let newCapacityLabel;
            let capacityStatus;
            let capacityColor;

            if (capacityPercentage >= THRESHOLD_FULL) {
              newCapacityLabel = 'üî¥ capacity:full';
              capacityStatus = 'FULL';
              capacityColor = 'D73A4A';
            } else if (capacityPercentage >= THRESHOLD_LIMITED) {
              newCapacityLabel = 'üü° capacity:limited';
              capacityStatus = 'LIMITED';
              capacityColor = 'FBCA04';
            } else {
              newCapacityLabel = 'üü¢ capacity:available';
              capacityStatus = 'AVAILABLE';
              capacityColor = '2EA44F';
            }

            console.log(`\nüéØ New Status: ${capacityStatus} (${newCapacityLabel})`);

            // Get current capacity labels in the repo
            const { data: allLabels } = await github.rest.issues.listLabelsForRepo({
              owner,
              repo,
              per_page: 100
            });

            const capacityLabels = allLabels.filter(l => l.name.startsWith('üü¢ capacity:') || l.name.startsWith('üü° capacity:') || l.name.startsWith('üî¥ capacity:'));
            console.log(`Found ${capacityLabels.length} capacity labels`);

            // Find or create capacity status issue
            const CAPACITY_ISSUE_TITLE = 'üìä A5-Reserve Team Capacity Status';
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'üë• team:a5-reserve,üìä capacity-status',
              per_page: 10
            });

            let capacityIssue = existingIssues.find(i => i.title === CAPACITY_ISSUE_TITLE);

            // Generate capacity report
            const timestamp = new Date().toISOString();
            const reportBody = `# üìä A5-Reserve Team Capacity Status

**Last Updated**: ${timestamp}
**Status**: **${capacityStatus}** (${capacityPercentage}%)

---

## üéØ Current Capacity

| Metric | Value |
|--------|-------|
| **Capacity Utilization** | ${capacityPercentage}% |
| **Complexity Points** | ${totalPoints} / ${TOTAL_CAPACITY} |
| **Active Tasks** | ${activeTasks.length} |
| **Team Size** | ${TEAM_MEMBERS} members |
| **Available Hours** | ${TOTAL_CAPACITY} hours/week |

## üìä Task Breakdown

| Priority | Count | Points Each | Total Points |
|----------|-------|-------------|--------------|
| üî• P0-Critical | ${taskBreakdown.P0} | ${COMPLEXITY_WEIGHTS.P0} | ${taskBreakdown.P0 * COMPLEXITY_WEIGHTS.P0} |
| ‚ö†Ô∏è P1-High | ${taskBreakdown.P1} | ${COMPLEXITY_WEIGHTS.P1} | ${taskBreakdown.P1 * COMPLEXITY_WEIGHTS.P1} |
| üìä P2-Medium | ${taskBreakdown.P2} | ${COMPLEXITY_WEIGHTS.P2} | ${taskBreakdown.P2 * COMPLEXITY_WEIGHTS.P2} |
| üìù P3-Low | ${taskBreakdown.P3} | ${COMPLEXITY_WEIGHTS.P3} | ${taskBreakdown.P3 * COMPLEXITY_WEIGHTS.P3} |
| **Total** | **${activeTasks.length}** | - | **${totalPoints}** |

## üé® Capacity Level

\`\`\`
${capacityPercentage < THRESHOLD_LIMITED ? 'üü¢' : capacityPercentage < THRESHOLD_FULL ? 'üü°' : 'üî¥'} [${'‚ñà'.repeat(Math.floor(capacityPercentage/5))}${'‚ñë'.repeat(20 - Math.floor(capacityPercentage/5))}] ${capacityPercentage}%
\`\`\`

- **0-70%**: üü¢ Available - Accepting new tasks
- **71-90%**: üü° Limited - Selective acceptance (P0/P1 only)
- **91-100%**: üî¥ Full - Critical tasks only (P0)

## üìã Active Tasks

${activeTasks.length > 0 ? activeTasks.map(issue => {
  const labels = issue.labels.map(l => l.name);
  const priority = labels.find(l => l.includes('priority:')) || 'No priority';
  const state = labels.find(l => l.includes('state:')) || 'No state';
  return \`- [#\${issue.number}](\${issue.html_url}) \${priority} \${state} - \${issue.title}\`;
}).join('\n') : '_No active tasks_'}

## üí° Recommendations

${capacityPercentage >= THRESHOLD_FULL ?
  '‚ö†Ô∏è **Team at full capacity!** Only accepting P0-Critical tasks. Consider:\n- Rejecting non-critical incoming tasks\n- Escalating to add temporary resources\n- Re-prioritizing current work' :
  capacityPercentage >= THRESHOLD_LIMITED ?
  '‚ö†Ô∏è **Team approaching capacity limit!** Accepting P0/P1 only. Monitor closely.' :
  '‚úÖ **Team has available capacity.** Ready to accept new tasks.'}

---

**Auto-generated by**: [A5-Reserve Capacity Monitor](.github/workflows/a5-capacity-monitor.yml)
**Next Update**: ~30 minutes (or on issue state change)
`;

            // Update or create capacity status issue
            if (capacityIssue) {
              console.log(\`\nüìù Updating capacity status issue #\${capacityIssue.number}\`);

              // Update issue body
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: capacityIssue.number,
                body: reportBody
              });

              // Remove old capacity labels
              const currentLabels = capacityIssue.labels.map(l => l.name);
              const oldCapacityLabels = currentLabels.filter(l =>
                l.startsWith('üü¢ capacity:') ||
                l.startsWith('üü° capacity:') ||
                l.startsWith('üî¥ capacity:')
              );

              for (const label of oldCapacityLabels) {
                if (label !== newCapacityLabel) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: capacityIssue.number,
                    name: label
                  });
                  console.log(\`  Removed label: \${label}\`);
                }
              }

              // Add new capacity label if not present
              if (!currentLabels.includes(newCapacityLabel)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: capacityIssue.number,
                  labels: [newCapacityLabel]
                });
                console.log(\`  Added label: \${newCapacityLabel}\`);
              }

            } else {
              console.log('\nüìù Creating new capacity status issue');

              const { data: newIssue } = await github.rest.issues.create({
                owner,
                repo,
                title: CAPACITY_ISSUE_TITLE,
                body: reportBody,
                labels: [
                  'üë• team:a5-reserve',
                  'üìä capacity-status',
                  newCapacityLabel
                ]
              });

              console.log(\`  Created issue #\${newIssue.number}\`);

              // Pin the issue
              // Note: Pinning requires GraphQL API, skipping for now
            }

            // Create summary for workflow
            core.summary
              .addHeading('A5-Reserve Capacity Report')
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Status', \`\${capacityStatus} (\${capacityPercentage}%)\`],
                ['Active Tasks', \`\${activeTasks.length}\`],
                ['Complexity Points', \`\${totalPoints} / \${TOTAL_CAPACITY}\`],
                ['Capacity Label', newCapacityLabel]
              ])
              .addRaw(\`\n### Task Breakdown\n\`)
              .addList([
                \`P0: \${taskBreakdown.P0} tasks (\${taskBreakdown.P0 * COMPLEXITY_WEIGHTS.P0} points)\`,
                \`P1: \${taskBreakdown.P1} tasks (\${taskBreakdown.P1 * COMPLEXITY_WEIGHTS.P1} points)\`,
                \`P2: \${taskBreakdown.P2} tasks (\${taskBreakdown.P2 * COMPLEXITY_WEIGHTS.P2} points)\`,
                \`P3: \${taskBreakdown.P3} tasks (\${taskBreakdown.P3 * COMPLEXITY_WEIGHTS.P3} points)\`
              ])
              .write();

            console.log('\n‚úÖ Capacity monitoring complete!');
