@startuml SWML - Execution Category
!theme blueprint
skinparam backgroundColor #F8F9FA

title SWML - Category Theoretic Structure\nExecution Category ğ“”\nVersion 1.0.0

' === Core Category Definition ===

class "Execution Category ğ“”" as category {
  **Objects (Spaces)**
  â€¢ â„ (Intent)
  â€¢ ğ’² (World)
  â€¢ ğ’® (Structure)
  â€¢ ğ’¯ (Task)
  â€¢ ğ’œ (Allocation)
  â€¢ â„› (Result)
  â€¢ ğ’Ÿ (Deliverable)
  â€¢ ğ’¦ (Knowledge)
  --
  **Morphisms (Phases)**
  â€¢ Î¸â‚: â„ Ã— ğ’² â†’ ğ’®
  â€¢ Î¸â‚‚: ğ’® Ã— ğ’² â†’ ğ’¯
  â€¢ Î¸â‚ƒ: ğ’¯ Ã— ğ’².r â†’ ğ’œ
  â€¢ Î¸â‚„: ğ’œ â†’ â„›
  â€¢ Î¸â‚…: â„› â†’ ğ’Ÿ
  â€¢ Î¸â‚†: ğ’Ÿ Ã— â„ Ã— ğ’² â†’ ğ’¦
  --
  **Laws**
  â€¢ Identity: âˆ€ A: id_A : A â†’ A
  â€¢ Composition: g âˆ˜ f : A â†’ C
  â€¢ Associativity: h âˆ˜ (g âˆ˜ f) = (h âˆ˜ g) âˆ˜ f
}

' === Monoid Structure ===

class "Monoid (ğ”¼, âˆ˜, id)" as monoid {
  **Binary Operation**
  âˆ˜: ğ”¼ Ã— ğ”¼ â†’ ğ”¼
  --
  **Identity Element**
  id: A â†’ A
  --
  **Laws**
  â€¢ (eâ‚ âˆ˜ eâ‚‚) âˆ˜ eâ‚ƒ = eâ‚ âˆ˜ (eâ‚‚ âˆ˜ eâ‚ƒ)
  â€¢ id âˆ˜ e = e âˆ˜ id = e
}

' === Functor ===

class "World State Functor F_W" as functor {
  **Signature**
  F_W: ğ“” â†’ ğ“”
  --
  **On Objects**
  F_W(X) = X Ã— ğ’²
  --
  **On Morphisms**
  F_W(f) = f Ã— id_W
  --
  **Laws**
  â€¢ F_W(id_X) = id_{F_W(X)}
  â€¢ F_W(g âˆ˜ f) = F_W(g) âˆ˜ F_W(f)
}

' === Natural Transformations ===

class "Natural Transformation Î·" as eta {
  **Signature**
  Î·: Id â†’ F_W
  --
  **Component at X**
  Î·_X: X â†’ X Ã— ğ’²
  --
  **Naturality**
  F_W(f) âˆ˜ Î·_X = Î·_Y âˆ˜ f
}

class "Natural Transformation Îµ" as epsilon {
  **Signature**
  Îµ: F_W â†’ Id
  --
  **Component at X**
  Îµ_X: X Ã— ğ’² â†’ X
  --
  **Projection**
  Ï€â‚: X Ã— ğ’² â†’ X
}

' === Task Algebra ===

class "Task Algebra" as task_algebra {
  **Sequential Composition (âˆ˜)**
  (Tâ‚ âˆ˜ Tâ‚‚)(x) = Tâ‚‚(Tâ‚(x))
  --
  **Parallel Composition (âŠ—)**
  (Tâ‚ âŠ— Tâ‚‚)(xâ‚, xâ‚‚) = (Tâ‚(xâ‚), Tâ‚‚(xâ‚‚))
  --
  **Conditional (âŠ•)**
  (Tâ‚ âŠ• Tâ‚‚)(x) = if cond then Tâ‚ else Tâ‚‚
  --
  **Iteration (*)**
  T* = â¨_{n=0}^{âˆ} Tâ¿
  --
  **Laws**
  â€¢ Associativity (âˆ˜, âŠ—)
  â€¢ Commutativity (âŠ— for independent)
  â€¢ Distributivity: Tâ‚ âˆ˜ (Tâ‚‚ âŠ— Tâ‚ƒ) = (Tâ‚ âˆ˜ Tâ‚‚) âŠ— (Tâ‚ âˆ˜ Tâ‚ƒ)
}

' === DAG Structure ===

class "DAG Structure" as dag {
  **Graph**
  G = (V, E, w)
  --
  **Vertices**
  V = {Tâ‚, Tâ‚‚, ..., Tâ‚™}
  --
  **Edges**
  E âŠ† V Ã— V
  --
  **Weights**
  w: E â†’ â„âº
  --
  **Topological Order**
  Ïƒ: V â†’ {1, 2, ..., n}
  --
  **Critical Path**
  CP = arg max_{path} âˆ‘_{e âˆˆ path} w(e)
}

' === Theorems ===

class "Composability Theorem" as thm1 {
  **Statement**
  âˆ€ Tâ‚, Tâ‚‚ âˆˆ ğ’¯:
    valid(Tâ‚) âˆ§ valid(Tâ‚‚)
    âŸ¹ valid(Tâ‚ âˆ˜ Tâ‚‚)
  --
  **Proof**
  Type safety + constraint propagation
}

class "Functor Preservation" as thm2 {
  **Statement**
  F_W preserves all categorical structure
  --
  **Proof**
  By functor laws + naturality
}

class "Yoneda Lemma" as thm3 {
  **Statement**
  Nat(Hom(A, -), F) â‰… F(A)
  --
  **Application**
  Natural transformations â‰… functor values
}

' === Rust Implementation ===

class "Category Trait (Rust)" as rust_cat {
  trait Morphism<A, B> {
    fn compose<C>(
      g: impl Morphism<B, C>
    ) -> impl Morphism<A, C>;

    fn id() -> impl Morphism<A, A>;
  }
}

class "Functor Trait (Rust)" as rust_func {
  trait Functor<F> {
    fn fmap<A, B>(
      f: impl Fn(A) -> B
    ) -> impl Fn(F<A>) -> F<B>;
  }
}

class "WorldState Struct (Rust)" as rust_world {
  struct WorldState<T> {
    value: T,
    world: World,
  }
  --
  impl<T> Functor for WorldState<T> {
    fn fmap<A, B>(f: fn(T) -> B)
      -> fn(WorldState<T>) -> WorldState<B>
  }
}

' === Relationships ===

category --> monoid : has structure
category --> functor : defines
functor --> eta : via
functor --> epsilon : via
category --> task_algebra : operations
task_algebra --> dag : implements

thm1 --> category : proves property
thm2 --> functor : proves property
thm3 --> eta : applies to

rust_cat --> rust_func
rust_func --> rust_world

' === Notes ===

note top of category
  **Execution Category ğ“”**
  Provides categorical semantics
  for the entire SWML system

  Objects = Spaces (8)
  Morphisms = Phase transitions (6)
end note

note bottom of functor
  **World State Functor F_W**
  Lifts every computation to
  include world state tracking

  Preserves identity & composition
end note

note right of task_algebra
  **Algebraic Operations**
  Enable compositional
  task construction

  âˆ˜ : Sequential
  âŠ— : Parallel
  âŠ• : Conditional
  * : Iteration
end note

legend right
  |= Symbol |= Meaning |
  | ğ“” | Execution Category |
  | ğ”¼ | Execution Engine Monoid |
  | F_W | World State Functor |
  | Î·, Îµ | Natural Transformations |
  | âˆ˜ | Sequential Composition |
  | âŠ— | Parallel Composition |
  | âŠ• | Conditional |
  | * | Iteration |
  | Î¸â‚-Î¸â‚† | Six Execution Phases |
endlegend

@enduml
