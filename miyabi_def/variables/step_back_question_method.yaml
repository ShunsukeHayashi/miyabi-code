# Step-back Question Method - YAML Definition
# Version: 1.1.0 (Corrected)
# Created: 2025-11-01

step_back_method:
  metadata:
    name: "Step-back Question Method"
    version: "1.1.0"
    created_at: "2025-11-01T00:00:00+09:00"
    author: "Shunsuke Hayashi"
    based_on: "SWML (Shunsuke's World Model Logic)"
    license: "Apache-2.0"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # æ•°å­¦çš„å®šç¾©
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mathematical_definition:
    function_signature: "F: Goal Ã— ğ’¬ â†’ Result"
    formula: "F(G, Q) = âˆ«_{A}^{Z} f(step, Q) d(step)"

    symbols:
      F:
        name: "Goal Achievement Function"
        type: "ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«é–¢æ•°"
        notation: "å¤§æ–‡å­—F"

      f:
        name: "Step Execution Function"
        type: "å€‹åˆ¥ã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°"
        notation: "å°æ–‡å­—f"

      G:
        name: "Goal"
        type: "é”æˆã™ã¹ãç›®æ¨™"

      Q:
        name: "Step-back Questions"
        type: "è³ªå•ã®é›†åˆ"
        notation: "ğ’¬"

      range:
        notation: "[A, Z]"
        meaning: "26ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ—ãƒ­ã‚»ã‚¹ç¯„å›²"
        steps: 26

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Step-back Questions å®šç¾©
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  step_back_questions:
    definition:
      type: "æœ¬è³ªã‚’å•ã†è³ªå•ã®é›†åˆ"
      purpose: "å•é¡Œã‚’ä¸€æ®µéšæŠ½è±¡åŒ–ã—ã€ã‚ˆã‚Šé«˜æ¬¡ã®è¦–ç‚¹ã‹ã‚‰è§£æ±ºç­–ã‚’å°å‡º"
      depth: "â‰¥ 1 (abstraction levels above current problem)"

    categories:
      why_questions:
        purpose: "æœ¬è³ªè¿½æ±‚"
        examples:
          - "Why is this goal important?"
          - "Why does this problem exist?"
          - "Why should we solve it this way?"

      what_if_questions:
        purpose: "å¯èƒ½æ€§æ¢ç´¢"
        examples:
          - "What if we approach this differently?"
          - "What are the fundamental principles?"
          - "What would success look like?"

      how_questions:
        purpose: "æ–¹æ³•è«–ç¢ºç«‹"
        examples:
          - "How does this relate to broader context?"
          - "How can we ensure quality?"
          - "How will we measure success?"

    standard_questions:
      q1: "What is the core problem we are trying to solve?"
      q2: "Why is this goal important in the bigger picture?"
      q3: "What are the fundamental principles guiding this work?"
      q4: "What would the ideal solution look like?"
      q5: "How does this connect to our broader objectives?"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # A to Z ã®26ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  process_steps:
    A_analyze:
      name: "Analyze"
      name_ja: "åˆ†æ"
      formula: "A: Goal â†’ Problem Understanding"
      step_back_question: "What is the core problem?"
      input: "Goal"
      output: "Problem Understanding"
      operations:
        - "Identify constraints"
        - "List available resources"
        - "Understand context"

    B_breakdown:
      name: "Break down"
      name_ja: "åˆ†è§£"
      formula: "B: Problem â†’ Sub-problems"
      step_back_question: "What are the fundamental components?"
      input: "Problem"
      output: "Sub-problems {Pâ‚, Pâ‚‚, ..., Pâ‚–}"
      operations:
        - "Decompose into sub-problems"
        - "Identify dependencies"
        - "Prioritize components"

    C_clarify:
      name: "Clarify"
      name_ja: "æ˜ç¢ºåŒ–"
      formula: "C: Sub-problems â†’ Clear Objectives"
      step_back_question: "What does success mean for each component?"
      input: "Sub-problems"
      output: "Clear Objectives with success criteria"
      operations:
        - "Define success criteria"
        - "Establish metrics"
        - "Set timeline"

    D_design:
      name: "Design"
      name_ja: "è¨­è¨ˆ"
      formula: "D: Objectives â†’ Solution Architecture"
      step_back_question: "What is the optimal structure?"
      input: "Objectives"
      output: "Architecture (components, relations, interfaces)"
      operations:
        - "Design system architecture"
        - "Define component interfaces"
        - "Plan integration strategy"

    E_enumerate:
      name: "Enumerate"
      name_ja: "åˆ—æŒ™"
      formula: "E: Architecture â†’ Task List"
      step_back_question: "What are all the necessary tasks?"
      input: "Architecture"
      output: "Complete task list {Tâ‚, Tâ‚‚, ..., Tâ‚˜}"
      operations:
        - "List all required tasks"
        - "Identify dependencies"
        - "Estimate effort"

    F_formulate:
      name: "Formulate"
      name_ja: "å®šå¼åŒ–"
      formula: "F: Tasks â†’ Mathematical Models"
      step_back_question: "How can we formally describe each task?"
      input: "Tasks"
      output: "Mathematical models"
      operations:
        - "Define inputs/outputs"
        - "Specify constraints"
        - "Identify optimization targets"

    G_generate:
      name: "Generate"
      name_ja: "ç”Ÿæˆ"
      formula: "G: Models â†’ Code/Artifacts"
      step_back_question: "What needs to be created?"
      input: "Models"
      output: "Code, docs, tests, config"
      operations:
        - "Generate code"
        - "Create documentation"
        - "Write tests"

    H_hypothesize:
      name: "Hypothesize"
      name_ja: "ä»®èª¬ç«‹æ¡ˆ"
      formula: "H: Current State â†’ Predictions"
      step_back_question: "What do we expect to happen?"
      input: "Current state"
      output: "Hypotheses"
      operations:
        - "Formulate hypotheses"
        - "Define testable predictions"
        - "Plan validation"

    I_implement:
      name: "Implement"
      name_ja: "å®Ÿè£…"
      formula: "I: Design â†’ Working Code"
      step_back_question: "How do we bring this to life?"
      input: "Design"
      output: "Working implementation"
      operations:
        - "Write code"
        - "Integrate components"
        - "Handle edge cases"

    J_judge:
      name: "Judge"
      name_ja: "åˆ¤æ–­"
      formula: "J: Implementation â†’ Quality Assessment"
      step_back_question: "Does this meet our standards?"
      input: "Implementation"
      output: "Quality score âˆˆ [0, 1]"
      operations:
        - "Assess code quality"
        - "Evaluate performance"
        - "Check completeness"

    K_know:
      name: "Know"
      name_ja: "èªè­˜"
      formula: "K: Results â†’ Knowledge"
      step_back_question: "What patterns can we extract?"
      input: "Results"
      output: "Extracted knowledge"
      operations:
        - "Extract patterns"
        - "Update knowledge base"
        - "Document insights"

    L_learn:
      name: "Learn"
      name_ja: "å­¦ç¿’"
      formula: "L: Experience â†’ Improved Strategy"
      step_back_question: "How can we do better next time?"
      input: "Experience"
      output: "Improved strategy"
      operations:
        - "Analyze what worked"
        - "Identify improvements"
        - "Update approach"

    M_measure:
      name: "Measure"
      name_ja: "æ¸¬å®š"
      formula: "M: System â†’ Metrics"
      step_back_question: "What are the key indicators?"
      input: "System"
      output: "Metrics {metricâ‚: valueâ‚, ...}"
      operations:
        - "Define KPIs"
        - "Collect measurements"
        - "Track progress"

    N_normalize:
      name: "Normalize"
      name_ja: "æ­£è¦åŒ–"
      formula: "N: Raw Data â†’ Standardized Format"
      step_back_question: "How do we make data comparable?"
      input: "Raw data"
      output: "Normalized data"
      operations:
        - "Apply normalization: (data - Î¼) / Ïƒ"
        - "Standardize formats"
        - "Remove outliers"

    O_optimize:
      name: "Optimize"
      name_ja: "æœ€é©åŒ–"
      formula: "O: Current Solution â†’ Optimal Solution"
      step_back_question: "What is the best possible solution?"
      input: "Current solution"
      output: "Optimal solution"
      operations:
        - "Apply optimization algorithms"
        - "Maximize quality function"
        - "Minimize resource usage"

    P_parallelize:
      name: "Parallelize"
      name_ja: "ä¸¦åˆ—åŒ–"
      formula: "P: Sequential Tasks â†’ Parallel Execution"
      step_back_question: "What can run concurrently?"
      input: "Sequential tasks"
      output: "Parallel execution plan"
      operations:
        - "Identify independent tasks"
        - "Plan parallel execution: Tâ‚ âŠ— Tâ‚‚ âŠ— ... âŠ— Tâ‚™"
        - "Coordinate results"

    Q_question:
      name: "Question"
      name_ja: "è³ªå•"
      formula: "Q: Current Understanding â†’ Deeper Insight"
      step_back_question: "What are we missing?"
      input: "Current understanding"
      output: "Deeper insights"
      operations:
        - "Ask step-back questions"
        - "Challenge assumptions"
        - "Seek fundamental principles"

    R_refactor:
      name: "Refactor"
      name_ja: "ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°"
      formula: "R: Working Code â†’ Clean Code"
      step_back_question: "How can we make this better?"
      input: "Working code"
      output: "Refactored code"
      operations:
        - "Improve readability"
        - "Enhance maintainability"
        - "Optimize performance"

    S_synthesize:
      name: "Synthesize"
      name_ja: "çµ±åˆ"
      formula: "S: Components â†’ Integrated System"
      step_back_question: "How do parts become a whole?"
      input: "Components {Câ‚, Câ‚‚, ..., Cáµ£}"
      output: "Integrated system"
      operations:
        - "Combine components"
        - "Ensure compatibility"
        - "Test integration"

    T_test:
      name: "Test"
      name_ja: "ãƒ†ã‚¹ãƒˆ"
      formula: "T: System â†’ Validation Results"
      step_back_question: "Does it actually work?"
      input: "System"
      output: "Test results {testâ‚: pass/fail, ...}"
      operations:
        - "Run unit tests"
        - "Execute integration tests"
        - "Perform system tests"

    U_unify:
      name: "Unify"
      name_ja: "çµ±ä¸€"
      formula: "U: Diverse Approaches â†’ Single Framework"
      step_back_question: "What unifies these approaches?"
      input: "Diverse approaches {Aâ‚, Aâ‚‚, ..., Aâ‚œ}"
      output: "Unified framework"
      operations:
        - "Find common patterns"
        - "Create abstraction"
        - "Define unified interface"

    V_validate:
      name: "Validate"
      name_ja: "æ¤œè¨¼"
      formula: "V: Solution â†’ Correctness Proof"
      step_back_question: "How do we know it's correct?"
      input: "Solution"
      output: "Validation proof"
      operations:
        - "Formal verification"
        - "Empirical testing"
        - "Peer review"

    W_write:
      name: "Write"
      name_ja: "è¨˜è¿°"
      formula: "W: Knowledge â†’ Documentation"
      step_back_question: "How do we share what we learned?"
      input: "Knowledge"
      output: "Documentation"
      operations:
        - "Write clear docs"
        - "Create examples"
        - "Explain rationale"

    X_execute:
      name: "eXecute"
      name_ja: "å®Ÿè¡Œ"
      formula: "X: Plan â†’ Action"
      step_back_question: "How do we make it happen?"
      input: "Plan"
      output: "Execution results"
      operations:
        - "Deploy system"
        - "Monitor execution"
        - "Adjust as needed"

    Y_yield:
      name: "Yield"
      name_ja: "ç”Ÿæˆ"
      formula: "Y: Process â†’ Final Result"
      step_back_question: "What is the final deliverable?"
      input: "Complete process"
      output: "Final result"
      operations:
        - "Package deliverable"
        - "Add metadata"
        - "Calculate quality metrics"

    Z_zeroin:
      name: "Zero-in"
      name_ja: "åæŸ"
      formula: "Z: Iterations â†’ Optimal Solution"
      step_back_question: "Have we reached the best solution?"
      input: "Iterative results"
      output: "Optimal solution"
      operations:
        - "Check convergence"
        - "Verify optimality"
        - "Finalize solution: lim_{nâ†’âˆ} Solutionâ‚™ = Solution*"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œé–¢æ•° f ã®å®šç¾©
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  step_execution_function:
    signature: "f: Step Ã— ğ’¬ â†’ StepResult"

    formula: "f(step, Q) = Execute(step) âŠ— Validate(step, Q) âŠ— Learn(step)"

    components:
      execute:
        description: "ã‚¹ãƒ†ãƒƒãƒ—ã®å®Ÿè¡Œ"
        operations:
          - "Run step-specific logic"
          - "Process inputs"
          - "Generate outputs"

      validate:
        description: "Step-backè³ªå•ã«ã‚ˆã‚‹æ¤œè¨¼"
        operations:
          - "Apply step-back questions"
          - "Check alignment with fundamental principles"
          - "Verify quality"

      learn:
        description: "ã‚¹ãƒ†ãƒƒãƒ—ã‹ã‚‰ã®å­¦ç¿’"
        operations:
          - "Extract patterns"
          - "Update knowledge"
          - "Improve future execution"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quality_metrics:
    process_quality:
      formula: "Process_Quality = âˆ_{step=A}^{Z} Step_Quality(step)"
      range: "[0, 1]"

    step_quality:
      formula: "Step_Quality(step) = Ï‰â‚Â·Completeness + Ï‰â‚‚Â·Accuracy + Ï‰â‚ƒÂ·Efficiency"
      weights:
        completeness: 0.4
        accuracy: 0.3
        efficiency: 0.3

    step_back_effect:
      formula: "Step_back_Effect = Quality(with_questions) / Quality(without_questions)"
      empirical_value: "1.5 ~ 2.0"
      description: "Step-backè³ªå•ã«ã‚ˆã‚Šå“è³ªãŒ1.5~2å€å‘ä¸Š"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # å®Ÿè£…ãƒãƒƒãƒ”ãƒ³ã‚°
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  implementation:
    rust_types:
      goal:
        type: "struct Goal"
        fields:
          - "description: String"
          - "success_criteria: Vec<Criterion>"
          - "constraints: Vec<Constraint>"

      question:
        type: "struct StepBackQuestion"
        fields:
          - "question: String"
          - "depth: usize"
          - "category: QuestionCategory"

      step:
        type: "enum Step"
        variants:
          - "A_Analyze"
          - "B_BreakDown"
          - "C_Clarify"
          - "... (26 variants total)"
          - "Z_ZeroIn"

      result:
        type: "struct Result"
        fields:
          - "deliverable: Deliverable"
          - "metadata: Metadata"
          - "quality: QualityScore"

    rust_functions:
      achieve_goal:
        signature: "fn achieve_goal(goal: Goal, questions: Vec<StepBackQuestion>) -> Result"
        implementation: |
          let steps = Step::iter_all();
          let step_results: Vec<StepResult> = steps
              .iter()
              .map(|step| execute_step(*step, &questions))
              .collect();
          integrate(step_results)

      execute_step:
        signature: "fn execute_step(step: Step, questions: &[StepBackQuestion]) -> StepResult"
        implementation: |
          match step {
              Step::A_Analyze => analyze(goal, questions),
              Step::B_BreakDown => break_down(problem, questions),
              // ... other 24 steps
              Step::Z_ZeroIn => zero_in(iterations, questions),
          }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ä½¿ç”¨ä¾‹
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  examples:
    example1:
      goal: "Build an AI agent system"

      step_back_questions:
        - "What makes an agent truly 'intelligent'?"
        - "What are the fundamental requirements for autonomy?"
        - "How do successful agent systems achieve reliability?"

      process_snippet:
        A_analyze:
          question: "What is the core problem?"
          answer: "Need autonomous task execution with learning capability"

        Z_zeroin:
          question: "What is the optimal solution?"
          answer: "Î©-System with 6-phase execution engine"
          convergence: "Achieved through iterative improvement"

      result:
        deliverable: "Miyabi Autonomous Development Framework"
        quality_score: 0.92
        metadata:
          lines_of_code: 50000
          test_coverage: 0.85

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  parameters:
    step_count: 26
    min_questions_per_step: 1
    recommended_questions: 3-5
    quality_threshold: 0.80
    convergence_epsilon: 0.01
