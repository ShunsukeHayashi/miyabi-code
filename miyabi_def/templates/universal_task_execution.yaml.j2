{# Universal Task Execution Logic - Jinja2 Template #}
{# Version: 1.0.0 - Ultra-Generalized Abstract System #}

---
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Î©-System: Universal Task Execution Engine
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

meta:
  system_name: "Î©-System"
  version: "1.0.0"
  abstraction_level: "âˆ"
  description: "å®Œå…¨æŠ½è±¡åŒ–ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ - ãƒ¦ãƒ¼ã‚¶ãƒ¼æ„å›³ã¨WorldçŠ¶æ…‹ã‹ã‚‰å‹•çš„ç”Ÿæˆ"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 1. World Abstraction - å¤–éƒ¨ç’°å¢ƒã®å®Œå…¨æŠ½è±¡åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

World:
  signature: "W(t, s, c, r, e) â†’ State"

  parameters:
    temporal:
      symbol: "t"
      type: "TimeVector"
      components:
        - name: "current_time"
          value: "{{ world.time.current }}"
        - name: "time_horizon"
          value: "{{ world.time.horizon }}"
        - name: "temporal_constraints"
          value: "{{ world.time.constraints }}"

    spatial:
      symbol: "s"
      type: "SpaceVector"
      components:
        - name: "physical_space"
          value: "{{ world.space.physical }}"
        - name: "digital_space"
          value: "{{ world.space.digital }}"
        - name: "abstract_space"
          value: "{{ world.space.abstract }}"

    contextual:
      symbol: "c"
      type: "ContextTensor"
      dimensions:
        - name: "domain_context"
          value: "{{ world.context.domain }}"
        - name: "user_context"
          value: "{{ world.context.user }}"
        - name: "system_context"
          value: "{{ world.context.system }}"

    resources:
      symbol: "r"
      type: "ResourceManifold"
      categories:
        computational:
          cpu: "{{ world.resources.compute.cpu }}"
          memory: "{{ world.resources.compute.memory }}"
          storage: "{{ world.resources.compute.storage }}"
        human:
          expertise: "{{ world.resources.human.expertise }}"
          availability: "{{ world.resources.human.availability }}"
        informational:
          knowledge_base: "{{ world.resources.info.kb }}"
          data_sources: "{{ world.resources.info.sources }}"

    environmental:
      symbol: "e"
      type: "EnvironmentState"
      factors:
        - name: "system_load"
          value: "{{ world.env.load }}"
        - name: "external_dependencies"
          value: "{{ world.env.dependencies }}"
        - name: "constraints"
          value: "{{ world.env.constraints }}"

  state_function:
    formula: "Î¨(W) = âˆ«[tâ‚€â†’tâ‚] âˆ‡(s, c, r, e) dt"
    description: "WorldçŠ¶æ…‹ã®æ™‚é–“ç©åˆ†ã«ã‚ˆã‚‹å…¨ä½“çŠ¶æ…‹å°å‡º"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 2. Intent Abstraction - ãƒ¦ãƒ¼ã‚¶ãƒ¼æ„å›³ã®å®Œå…¨æŠ½è±¡åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Intent:
  signature: "I(g, p, o, m) â†’ Objective"

  parameters:
    goal:
      symbol: "g"
      type: "GoalVector"
      structure:
        primary: "{{ intent.goal.primary }}"
        secondary: "{{ intent.goal.secondary }}"
        implicit: "{{ intent.goal.implicit }}"

    preferences:
      symbol: "p"
      type: "PreferenceMatrix"
      dimensions:
        quality_vs_speed: "{{ intent.pref.quality_speed }}"
        cost_vs_performance: "{{ intent.pref.cost_performance }}"
        simplicity_vs_feature: "{{ intent.pref.simplicity_feature }}"

    objectives:
      symbol: "o"
      type: "ObjectiveSet"
      elements:
{% for objective in intent.objectives %}
        - id: "{{ objective.id }}"
          type: "{{ objective.type }}"
          priority: "{{ objective.priority }}"
          metrics: "{{ objective.metrics }}"
{% endfor %}

    modality:
      symbol: "m"
      type: "ModalitySpace"
      supported:
        - "text"
        - "code"
        - "visual"
        - "data"
        - "hybrid"

  mapping_function:
    formula: "Î¦(I) = arg max[Tâˆˆğ•‹] âŸ¨I, TâŸ©"
    description: "æ„å›³ç©ºé–“ã‹ã‚‰ã‚¿ã‚¹ã‚¯ç©ºé–“ã¸ã®æœ€é©å†™åƒ"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 3. Task Abstraction - ã‚¿ã‚¹ã‚¯ã®å®Œå…¨æŠ½è±¡åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Task:
  signature: "T(f, i, o, d, c) â†’ Execution"

  abstract_definition:
    function:
      symbol: "f"
      type: "TransformFunction"
      notation: "f: Input â†’ Output"
      properties:
        - "deterministic or stochastic"
        - "pure or impure"
        - "atomic or composite"

    input:
      symbol: "i"
      type: "InputManifold"
      structure:
        schema: "{{ task.input.schema }}"
        constraints: "{{ task.input.constraints }}"
        dependencies: "{{ task.input.dependencies }}"

    output:
      symbol: "o"
      type: "OutputManifold"
      structure:
        schema: "{{ task.output.schema }}"
        guarantees: "{{ task.output.guarantees }}"
        side_effects: "{{ task.output.side_effects }}"

    dependencies:
      symbol: "d"
      type: "DependencyGraph"
      structure: "DAG(V, E)"
      properties:
        vertices: "{{ task.deps.vertices }}"
        edges: "{{ task.deps.edges }}"
        order: "{{ task.deps.order }}"

    constraints:
      symbol: "c"
      type: "ConstraintSet"
      categories:
        temporal: "{{ task.constraints.time }}"
        resource: "{{ task.constraints.resource }}"
        logical: "{{ task.constraints.logic }}"

  composition_algebra:
    sequential: "Tâ‚ âˆ˜ Tâ‚‚ = Tâ‚ƒ"
    parallel: "Tâ‚ âŠ— Tâ‚‚ = Tâ‚ƒ"
    conditional: "Tâ‚ âŠ• Tâ‚‚ = Tâ‚ƒ"
    iterative: "T* = âŠ•[n=0â†’âˆ] Tâ¿"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 4. Execution Engine - å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³ã®æŠ½è±¡åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ExecutionEngine:
  signature: "E(W, I, T) â†’ Result"

  phases:

    # Phase 1: Intent Understanding
    phase_understanding:
      name: "Î˜â‚: Intentâ†’Structure"
      function: "Î¸â‚(I, W) â†’ S"
      operations:
        - name: "parse"
          formula: "P(I) â†’ I'"
        - name: "contextualize"
          formula: "C(I', W) â†’ I''"
        - name: "validate"
          formula: "V(I'') â†’ {valid, Â¬valid}"
      output: "Structured Intent (S)"

    # Phase 2: Task Generation
    phase_generation:
      name: "Î˜â‚‚: Structureâ†’Tasks"
      function: "Î¸â‚‚(S, W) â†’ ğ•‹"
      operations:
        - name: "decompose"
          formula: "D(S) â†’ {Tâ‚, Tâ‚‚, ..., Tâ‚™}"
        - name: "prioritize"
          formula: "Ï€(ğ•‹) â†’ ğ•‹'"
        - name: "optimize"
          formula: "O(ğ•‹', W) â†’ ğ•‹*"
      output: "Task Set (ğ•‹*)"

    # Phase 3: Resource Allocation
    phase_allocation:
      name: "Î˜â‚ƒ: Tasksâ†’Resources"
      function: "Î¸â‚ƒ(ğ•‹*, W.r) â†’ A"
      operations:
        - name: "estimate"
          formula: "Îµ(T) â†’ rÌ‚"
        - name: "allocate"
          formula: "Î±(ğ•‹*, W.r) â†’ A"
        - name: "schedule"
          formula: "Ïƒ(A) â†’ Schedule"
      output: "Allocation Map (A)"

    # Phase 4: Parallel Execution
    phase_execution:
      name: "Î˜â‚„: Scheduleâ†’Results"
      function: "Î¸â‚„(Schedule, A) â†’ R"
      operations:
        - name: "dispatch"
          formula: "Î´(T, A) â†’ Worker"
        - name: "execute"
          formula: "Îµ(Worker, T) â†’ r"
        - name: "monitor"
          formula: "Î¼(Worker*) â†’ Status"
      output: "Result Set (R)"

    # Phase 5: Integration
    phase_integration:
      name: "Î˜â‚…: Resultsâ†’Deliverable"
      function: "Î¸â‚…(R) â†’ D"
      operations:
        - name: "aggregate"
          formula: "â¨[i=1â†’n] ráµ¢ â†’ R'"
        - name: "synthesize"
          formula: "Î£(R') â†’ D'"
        - name: "validate"
          formula: "V(D', I) â†’ D"
      output: "Final Deliverable (D)"

    # Phase 6: Feedback Loop
    phase_feedback:
      name: "Î˜â‚†: Resultâ†’Knowledge"
      function: "Î¸â‚†(D, I, W) â†’ K"
      operations:
        - name: "evaluate"
          formula: "E(D, I.o) â†’ Score"
        - name: "learn"
          formula: "L(D, Score) â†’ Î”K"
        - name: "update"
          formula: "U(K, Î”K) â†’ K'"
      output: "Updated Knowledge (K')"

  total_function:
    formula: "E = Î¸â‚† âˆ˜ Î¸â‚… âˆ˜ Î¸â‚„ âˆ˜ Î¸â‚ƒ âˆ˜ Î¸â‚‚ âˆ˜ Î¸â‚"
    description: "å®Œå…¨ãªå®Ÿè¡Œã¯6ã¤ã®ãƒ•ã‚§ãƒ¼ã‚ºã®åˆæˆé–¢æ•°"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 5. Dynamic Workflow Generation - å‹•çš„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ç”Ÿæˆ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WorkflowGenerator:
  signature: "G(I, W) â†’ Workflow"

  generation_strategy:
    template_based:
      condition: "âˆƒT âˆˆ Templates: similarity(I, T.pattern) > threshold"
      action: "instantiate(T, I, W)"

    composition_based:
      condition: "âˆƒ{Tâ‚, ..., Tâ‚™} âˆˆ Primitives: compose(T*) â‰… I"
      action: "synthesize({Tâ‚, ..., Tâ‚™}, I, W)"

    learning_based:
      condition: "âˆƒH âˆˆ History: analogy(I, H) > threshold"
      action: "adapt(H, I, W)"

    generative:
      condition: "otherwise"
      action: "generate_novel(I, W)"

  workflow_template:
    structure: |
      Workflow[{{ workflow.id }}]:
        name: "{{ workflow.name }}"
        intent_signature: "{{ intent.goal.primary | replace(' ', '_') | lower }}"
        world_timestamp: "{{ world.time.current }}"

        nodes:
{% for node in workflow.nodes %}
          - id: "{{ node.id }}"
            type: "{{ node.type }}"
            function: "{{ node.function }}"
            inputs:
{% for input in node.inputs %}
              - source: "{{ input.source }}"
                transform: "{{ input.transform }}"
{% endfor %}
            outputs:
{% for output in node.outputs %}
              - target: "{{ output.target }}"
                schema: "{{ output.schema }}"
{% endfor %}
            resources:
              compute: "{{ node.resources.compute }}"
              time: "{{ node.resources.time }}"
            constraints:
{% for constraint in node.constraints %}
              - type: "{{ constraint.type }}"
                condition: "{{ constraint.condition }}"
{% endfor %}
{% endfor %}

        edges:
{% for edge in workflow.edges %}
          - from: "{{ edge.from }}"
            to: "{{ edge.to }}"
            type: "{{ edge.type }}"
            condition: "{{ edge.condition | default('always') }}"
{% endfor %}

        execution_strategy:
          parallelism: "{{ workflow.execution.parallelism }}"
          fault_tolerance: "{{ workflow.execution.fault_tolerance }}"
          optimization: "{{ workflow.execution.optimization }}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 6. Meta-Learning System - ãƒ¡ã‚¿å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MetaLearning:
  signature: "M(H, E) â†’ Strategy"

  knowledge_base:
    schema: |
      K = {
        patterns: {
          intent_pattern â†’ task_pattern,
          task_pattern â†’ implementation_pattern,
          error_pattern â†’ resolution_pattern
        },
        metrics: {
          success_rate: Float,
          efficiency: Float,
          quality: Float
        },
        history: [
          (Intent, World, Workflow, Result, Feedback)*
        ]
      }

  learning_functions:
    pattern_extraction:
      formula: "P(H) = arg max[pâˆˆğ’«] frequency(p, H)"
      description: "å±¥æ­´ã‹ã‚‰é »å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º"

    strategy_optimization:
      formula: "S* = arg max[sâˆˆğ’®] ğ”¼[Q(s, H)]"
      description: "æœŸå¾…å“è³ªã‚’æœ€å¤§åŒ–ã™ã‚‹æˆ¦ç•¥ã‚’é¸æŠ"

    adaptation:
      formula: "A(s, w) = s + Î±âˆ‡Q(s, w)"
      description: "WorldçŠ¶æ…‹ã«å¿œã˜ã¦æˆ¦ç•¥ã‚’é©å¿œ"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 7. Output Abstraction - å‡ºåŠ›ã®æŠ½è±¡åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Output:
  signature: "O(R, I, F) â†’ Artifact"

  transformation_pipeline:
    - stage: "extraction"
      function: "Î»R. extract_essence(R)"

    - stage: "formatting"
      function: "Î»E. format(E, I.m)"

    - stage: "enrichment"
      function: "Î»F. enrich(F, metadata)"

    - stage: "validation"
      function: "Î»A. validate(A, I.o)"

  artifact_schema:
    structure: |
      Artifact:
        content:
          primary: "{{ output.content.primary.format if output.content.primary is defined else 'text' }}"
          supplementary: "{{ output.content.supplementary | length if output.content.supplementary is defined else 0 }} items"

        metadata:
          intent_reference: "{{ intent.goal.primary if intent.goal.primary is defined else 'unknown' }}"
          world_timestamp: "{{ world.time.current if world.time.current is defined else 'N/A' }}"
          execution_status: "completed"
          quality_metrics: "{{ output.metrics if output.metrics is defined else {} }}"

        provenance:
          sources: "{{ output.provenance.sources | join(', ') if output.provenance.sources is defined else 'N/A' }}"
          transformations: "{{ output.provenance.transforms | join(', ') if output.provenance.transforms is defined else 'N/A' }}"
          timestamp: "{{ output.timestamp if output.timestamp is defined else 'N/A' }}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 8. System Properties - ã‚·ã‚¹ãƒ†ãƒ ç‰¹æ€§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SystemProperties:

  compositionality:
    property: "âˆ€Tâ‚, Tâ‚‚: valid(Tâ‚) âˆ§ valid(Tâ‚‚) âŸ¹ valid(Tâ‚ âˆ˜ Tâ‚‚)"
    description: "æœ‰åŠ¹ãªã‚¿ã‚¹ã‚¯ã®åˆæˆã¯å¸¸ã«æœ‰åŠ¹"

  convergence:
    property: "lim[nâ†’âˆ] E^n(I, W) â†’ Result*"
    description: "åå¾©å®Ÿè¡Œã¯æœ€é©è§£ã«åæŸ"

  adaptability:
    property: "âˆ€W, W': d(W, W') < Îµ âŸ¹ d(E(I,W), E(I,W')) < Î´(Îµ)"
    description: "WorldçŠ¶æ…‹ã®å°å¤‰åŒ–ã«å¯¾ã™ã‚‹é€£ç¶šæ€§"

  scalability:
    property: "T(n) = O(f(n))"
    description: "å•é¡Œã‚µã‚¤ã‚ºã«å¯¾ã™ã‚‹è¨ˆç®—è¤‡é›‘åº¦"

  robustness:
    property: "âˆ€noise: â€–E(I+noise, W) - E(I, W)â€– < tolerance"
    description: "ãƒã‚¤ã‚ºã«å¯¾ã™ã‚‹é ‘å¥æ€§"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 9. Mathematical Foundation - æ•°å­¦çš„åŸºç¤
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MathematicalFoundation:

  topology:
    intent_space: "(â„, Ï„_â„)"
    world_space: "(ğ’², Ï„_ğ’²)"
    task_space: "(ğ•‹, Ï„_ğ•‹)"
    result_space: "(â„, Ï„_â„)"

  mappings:
    intent_to_task: "Î¦: â„ Ã— ğ’² â†’ ğ•‹"
    task_to_result: "Î¨: ğ•‹ Ã— ğ’² â†’ â„"
    end_to_end: "Î©: â„ Ã— ğ’² â†’ â„ where Î© = Î¨ âˆ˜ Î¦"

  optimization:
    objective: "max Q(Î©(I, W)) subject to C(W)"
    constraints:
      - "resource_usage(Î©) â‰¤ W.r"
      - "execution_time(Î©) â‰¤ W.t.horizon"
      - "quality(Î©(I, W)) â‰¥ I.o.min_quality"

  measure_theory:
    probability_space: "(Î©, â„±, â„™)"
    expectation: "ğ”¼[Q] = âˆ«_Î© Q(Ï‰) dâ„™(Ï‰)"
    variance: "Var[Q] = ğ”¼[(Q - ğ”¼[Q])Â²]"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Â§ 10. Instantiation Example - å…·ä½“åŒ–ä¾‹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

InstantiationExample:
  comment: "ä»¥ä¸‹ã¯å…·ä½“çš„ãªãƒ¦ãƒ¼ã‚¶ãƒ¼æ„å›³ã«å¯¾ã™ã‚‹å‹•çš„ç”Ÿæˆä¾‹"

  user_intent_raw: "{{ user_input }}"

  parsed_intent:
    goal:
      primary: "{{ intent.goal.primary }}"
    preferences:
      quality_speed: "{{ intent.pref.quality_speed }}"
    objectives:
{% for obj in intent.objectives %}
      - {{ obj }}
{% endfor %}

  world_snapshot:
    time: "{{ world.time.current }}"
    resources_available:
      compute: "{{ world.resources.compute }}"
    constraints:
      - "{{ world.constraints | join('\n      - ') }}"

  generated_workflow:
    name: "{{ workflow.name if workflow.name is defined else 'N/A' }}"
    nodes_count: "{{ workflow.nodes | length if workflow.nodes is defined else 0 }}"
    edges_count: "{{ workflow.edges | length if workflow.edges is defined else 0 }}"

  execution_plan:
    total_phases: "{{ execution_plan.phases | length if execution_plan.phases is defined else 0 }}"
    estimated_time: "{{ execution_plan.total_estimated_time if execution_plan.total_estimated_time is defined else 'N/A' }}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# End of Î©-System Universal Task Execution Logic
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
