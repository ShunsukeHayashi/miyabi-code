//! Manual Execution Mode
//!
//! Guides human developer (via Claude Code) to implement features manually.
//! This mode creates a Worktree and detailed execution context, then waits
//! for the implementation to complete.

use miyabi_types::Task;
use std::fs;
use std::path::{Path, PathBuf};

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

use super::ModeExecutor;

/// Manual mode executor
pub struct ManualMode {
    /// Working directory for the agent
    work_dir: PathBuf,
}

impl ManualMode {
    /// Create a new manual mode executor
    pub fn new<P: AsRef<Path>>(work_dir: P) -> Self {
        Self {
            work_dir: work_dir.as_ref().to_path_buf(),
        }
    }

    /// Generate detailed execution context for manual implementation
    fn generate_execution_context(&self, task: &Task) -> Result<String> {
        // Extract issue number from metadata
        let issue_number = task
            .metadata
            .as_ref()
            .and_then(|m| m.get("issue_number"))
            .and_then(|v| v.as_u64())
            .unwrap_or(0);
        let title = if task.title.is_empty() {
            "Untitled Task".to_string()
        } else {
            task.title.clone()
        };

        let description_text = if task.description.is_empty() {
            "No description provided".to_string()
        } else {
            task.description.clone()
        };

        let context = format!(
            r#"# ü§ñ Manual Execution Context - CodeGenAgent

**Issue**: #{issue_number}
**Title**: {title}
**Mode**: Manual (Claude Code Session)
**Agent**: CodeGenAgent („Å§„Åè„Çã„Çì)

---

## üìã Task Overview

{description}

---

## üéØ Implementation Instructions

This issue requires **manual implementation** in the current Claude Code session.

### Step-by-Step Guide

1. **Read Design Documents**
   - Review all relevant design docs in `docs/` directory
   - Check `CLAUDE.md` and `.claude/context/` for project context
   - Understand the existing architecture

2. **Implement Required Features**
   - Follow the requirements listed in Issue #{issue_number}
   - Adhere to Miyabi coding standards (see `.claude/context/rust.md`)
   - Use appropriate Rust patterns and error handling

3. **Write Tests**
   - Add unit tests for new functionality
   - Add integration tests where appropriate
   - Ensure test coverage ‚â• 80%

4. **Run Quality Checks**
   ```bash
   # Format code
   cargo fmt --all

   # Run clippy
   cargo clippy --all -- -D warnings

   # Run tests
   cargo test --all

   # Check build
   cargo build --release
   ```

5. **Commit Changes**
   - Use Conventional Commits format
   - Example: `feat(desktop): add tmux integration for external agents`
   - Include co-author line:
     ```
     Co-Authored-By: CodeGenAgent <codegen@miyabi.dev>
     ```

6. **Mark as Complete**
   - Update Issue #{issue_number} with progress
   - Comment on completion status
   - Request review if needed

---

## üìÅ Working Directory

Current Worktree: `{worktree_path}`

All implementation should be done in this directory.

---

## üîí Important Rules

1. **Follow Miyabi Conventions**: All code must follow `.claude/context/rust.md`
2. **No Direct Push to Main**: Work in this Worktree, then merge via PR
3. **Test Before Commit**: All tests must pass before committing
4. **Security First**: Check for vulnerabilities (command injection, etc.)

---

## üìö Reference Documents

- [Project Root CLAUDE.md](../CLAUDE.md)
- [Rust Guidelines](.claude/context/rust.md)
- [Architecture](.claude/context/architecture.md)
- [Issue #{issue_number}](https://github.com/customer-cloud/miyabi-private/issues/{issue_number})

---

## ‚úÖ Completion Checklist

- [ ] All requirements from Issue #{issue_number} implemented
- [ ] Unit tests written and passing
- [ ] Integration tests added (if applicable)
- [ ] `cargo fmt` applied
- [ ] `cargo clippy` passes with no warnings
- [ ] `cargo test --all` passes
- [ ] Documentation updated (if needed)
- [ ] Commit message follows Conventional Commits
- [ ] Issue #{issue_number} updated with status

---

**‚è±Ô∏è Estimated Time**: Varies based on complexity

**ü§ñ Agent Note**: This is a **manual mode** execution. The agent has prepared the environment and context. Human implementation is now required via Claude Code session.

**üìû For Help**: Refer to `.claude/TROUBLESHOOTING.md` or consult Miyabi documentation.

---

Generated by: CodeGenAgent (Manual Mode)
Timestamp: {timestamp}
"#,
            issue_number = issue_number,
            title = title,
            description = description_text,
            worktree_path = self.work_dir.display(),
            timestamp = chrono::Utc::now().to_rfc3339(),
        );

        Ok(context)
    }

    /// Create execution context file in worktree
    fn create_context_file(&self, task: &Task) -> Result<PathBuf> {
        let context_content = self.generate_execution_context(task)?;
        let context_path = self.work_dir.join("EXECUTION_CONTEXT.md");

        fs::write(&context_path, &context_content).map_err(|e| {
            format!("Failed to write execution context to {:?}: {}", context_path, e)
        })?;

        Ok(context_path)
    }

    /// Print manual mode instructions to stdout
    fn print_instructions(&self, task: &Task, context_file: &Path) -> Result<()> {
        // Extract issue number from metadata
        let issue_number = task
            .metadata
            .as_ref()
            .and_then(|m| m.get("issue_number"))
            .and_then(|v| v.as_u64())
            .unwrap_or(0);

        println!("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        println!("‚îÇ  ü§ñ CodeGenAgent - Manual Mode Activated                      ‚îÇ");
        println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");

        println!("üìã Issue: #{}", issue_number);
        println!("üìÇ Worktree: {}", self.work_dir.display());
        println!("üìù Context File: {}", context_file.display());

        println!("\nüéØ Next Steps:");
        println!("   1. Read the execution context:");
        println!("      cat {}", context_file.display());
        println!();
        println!("   2. Navigate to the worktree:");
        println!("      cd {}", self.work_dir.display());
        println!();
        println!("   3. Implement the features as described");
        println!("   4. Run quality checks: cargo fmt && cargo clippy && cargo test");
        println!("   5. Commit your changes with Conventional Commits format");
        println!();
        println!("‚è≥ This agent will wait for manual completion...");
        println!("   (Press Ctrl+C to cancel)");
        println!();

        Ok(())
    }
}

impl ModeExecutor for ManualMode {
    async fn execute(&self, task: &Task) -> Result<String> {
        // Create execution context file
        let context_file = self
            .create_context_file(task)
            .map_err(|e| format!("Failed to create execution context file: {}", e))?;

        // Print instructions for human
        self.print_instructions(task, &context_file)?;

        // In manual mode, we return immediately with instructions
        // The actual implementation is done by the human in Claude Code session
        Ok(format!(
            "Manual mode activated. Execution context created at: {}\n\
             Please implement the features manually in the Claude Code session.",
            context_file.display()
        ))
    }

    fn mode_name(&self) -> &'static str {
        "manual"
    }

    fn requires_human(&self) -> bool {
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_manual_mode_execution() {
        let temp_dir = TempDir::new().unwrap();
        let manual_mode = ManualMode::new(temp_dir.path());

        let mut metadata = std::collections::HashMap::new();
        metadata.insert("issue_number".to_string(), serde_json::json!(670));

        let task = Task {
            id: "test-task".to_string(),
            title: "Test Feature".to_string(),
            description: "Implement test feature".to_string(),
            task_type: miyabi_types::task::TaskType::Feature,
            priority: 1,
            severity: None,
            impact: None,
            assigned_agent: None,
            dependencies: Vec::new(),
            estimated_duration: None,
            status: None,
            start_time: None,
            end_time: None,
            metadata: Some(metadata),
        };

        let result = manual_mode.execute(&task).await;
        assert!(result.is_ok());

        // Check that EXECUTION_CONTEXT.md was created
        let context_file = temp_dir.path().join("EXECUTION_CONTEXT.md");
        assert!(context_file.exists());

        // Verify context content
        let content = fs::read_to_string(&context_file).unwrap();
        assert!(content.contains("Issue**: #670"));
        assert!(content.contains("Test Feature"));
    }

    #[test]
    fn test_generate_execution_context() {
        let temp_dir = TempDir::new().unwrap();
        let manual_mode = ManualMode::new(temp_dir.path());

        let mut metadata = std::collections::HashMap::new();
        metadata.insert("issue_number".to_string(), serde_json::json!(123));

        let task = Task {
            id: "test-task".to_string(),
            title: "Sample Task".to_string(),
            description: "This is a test description".to_string(),
            task_type: miyabi_types::task::TaskType::Feature,
            priority: 1,
            severity: None,
            impact: None,
            assigned_agent: None,
            dependencies: Vec::new(),
            estimated_duration: None,
            status: None,
            start_time: None,
            end_time: None,
            metadata: Some(metadata),
        };

        let context = manual_mode.generate_execution_context(&task).unwrap();

        assert!(context.contains("#123"));
        assert!(context.contains("Sample Task"));
        assert!(context.contains("This is a test description"));
        assert!(context.contains("Manual Execution Context"));
    }
}
