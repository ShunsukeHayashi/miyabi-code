//! コンテキストファイル生成ユーティリティ
//!
//! CodeGenAgent が Claude Code や他のツールと連携する際に必要な
//! 各種コンテキストを構築し、ファイルへ書き出す。

use miyabi_agent_integrations::PotpieIntegration;
use miyabi_potpie::PotpieConfig;
use miyabi_types::error::MiyabiError;
use miyabi_types::{AgentConfig, Task};
use std::path::Path;

/// Claude Code 向けの EXECUTION_CONTEXT.md を生成
pub fn build_execution_context(task: &Task) -> String {
    let mut context = String::new();

    context.push_str("# Execution Context\n\n");
    context.push_str(&format!("**Task ID**: {}\n\n", task.id));
    context.push_str(&format!("**Task Title**: {}\n\n", task.title));
    context.push_str(&format!("**Task Type**: {:?}\n\n", task.task_type));
    context.push_str(&format!("**Priority**: {}\n\n", task.priority));

    if let Some(ref severity) = task.severity {
        context.push_str(&format!("**Severity**: {:?}\n\n", severity));
    }

    if let Some(ref impact) = task.impact {
        context.push_str(&format!("**Impact**: {:?}\n\n", impact));
    }

    context.push_str("## Description\n\n");
    context.push_str(&task.description);
    context.push_str("\n\n");

    if !task.dependencies.is_empty() {
        context.push_str("## Dependencies\n\n");
        for dep in &task.dependencies {
            context.push_str(&format!("- {}\n", dep));
        }
        context.push('\n');
    }

    if let Some(duration) = task.estimated_duration {
        context.push_str(&format!("**Estimated Duration**: {} minutes\n\n", duration));
    }

    context.push_str("## Instructions\n\n");
    context.push_str("Please implement the following:\n\n");
    context.push_str("1. Analyze the task requirements\n");
    context.push_str("2. Generate the necessary code changes\n");
    context.push_str("3. Create tests for the new functionality\n");
    context.push_str("4. Add documentation (Rustdoc comments)\n");
    context.push_str("5. Commit the changes with a descriptive message\n\n");

    context.push_str("---\n\n");
    context.push_str("*Generated by Miyabi CodeGenAgent*\n");

    context
}

/// Potpie 統合を利用した拡張版コンテキストを生成
#[allow(dead_code)] // 既存の呼び出し箇所が有効化されたら外す
pub async fn build_enhanced_execution_context(
    task: &Task,
    potpie_config: Option<PotpieConfig>,
) -> String {
    let mut context = build_execution_context(task);

    if let Some(config) = potpie_config {
        let potpie = PotpieIntegration::new(Some(config));

        if potpie.is_available().await {
            tracing::info!("Fetching existing implementations from Potpie");

            match potpie
                .find_existing_implementations(&task.description)
                .await
            {
                Ok(existing_code) if !existing_code.is_empty() => {
                    // Instructions セクションの直前に挿入
                    let instructions_marker = "## Instructions\n\n";
                    if let Some(pos) = context.find(instructions_marker) {
                        context.insert_str(pos, &existing_code);
                    } else {
                        let footer_marker = "---\n\n";
                        if let Some(pos) = context.find(footer_marker) {
                            context.insert_str(pos, &existing_code);
                        } else {
                            context.push_str(&existing_code);
                        }
                    }
                }
                Ok(_) => {
                    tracing::debug!("No existing implementations found");
                }
                Err(e) => {
                    tracing::warn!("Failed to fetch existing implementations: {}", e);
                }
            }
        } else {
            tracing::debug!("Potpie not available, using base context");
        }
    }

    context
}

/// Claude Code 用 .agent-context.json を生成
pub fn build_agent_context_json(config: &AgentConfig, task: &Task) -> Result<String, MiyabiError> {
    let context = serde_json::json!({
        "agentType": "CodeGenAgent",
        "agentStatus": "executing",
        "task": {
            "id": task.id,
            "title": task.title,
            "description": task.description,
            "taskType": task.task_type,
            "priority": task.priority,
            "severity": task.severity,
            "impact": task.impact,
            "dependencies": task.dependencies,
            "estimatedDuration": task.estimated_duration,
        },
        "config": {
            "useTaskTool": config.use_task_tool,
            "useWorktree": config.use_worktree,
        },
        "promptPath": ".claude/agents/prompts/coding/codegen-agent-prompt.md",
    });

    serde_json::to_string_pretty(&context)
        .map_err(|e| MiyabiError::Unknown(format!("Failed to serialize agent context: {}", e)))
}

/// タスク種別に応じたデフォルトファイル名を返す
pub fn determine_code_filename(task: &Task) -> String {
    match task.task_type {
        miyabi_types::task::TaskType::Feature => "src/feature.rs".to_string(),
        miyabi_types::task::TaskType::Bug => "src/fix.rs".to_string(),
        miyabi_types::task::TaskType::Refactor => "src/refactor.rs".to_string(),
        _ => "src/generated.rs".to_string(),
    }
}

/// ワークツリーへコンテキストファイルを書き出す
pub async fn write_context_files(
    worktree_path: &Path,
    config: &AgentConfig,
    task: &Task,
) -> Result<(), MiyabiError> {
    let context_md = build_execution_context(task);
    let context_path = worktree_path.join("EXECUTION_CONTEXT.md");
    tokio::fs::write(&context_path, context_md)
        .await
        .map_err(|e| {
            MiyabiError::Unknown(format!("Failed to write EXECUTION_CONTEXT.md: {}", e))
        })?;

    let context_json = build_agent_context_json(config, task)?;
    let json_path = worktree_path.join(".agent-context.json");
    tokio::fs::write(&json_path, context_json)
        .await
        .map_err(|e| MiyabiError::Unknown(format!("Failed to write .agent-context.json: {}", e)))?;

    Ok(())
}
