//! コンテキストファイル生成ユーティリティ
//!
//! CodeGenAgent が Claude Code や他のツールと連携する際に必要な
//! 各種コンテキストを構築し、ファイルへ書き出す。

use miyabi_agent_integrations::PotpieIntegration;
use miyabi_knowledge::potpie::PotpieConfig;
use miyabi_types::error::MiyabiError;
use miyabi_types::{AgentConfig, Task};
use std::path::Path;

/// Claude Code 向けの EXECUTION_CONTEXT.md を生成
pub fn build_execution_context(task: &Task) -> String {
    let mut context = String::new();

    context.push_str("# Execution Context\n\n");
    context.push_str(&format!("**Task ID**: {}\n\n", task.id));
    context.push_str(&format!("**Task Title**: {}\n\n", task.title));
    context.push_str(&format!("**Task Type**: {:?}\n\n", task.task_type));
    context.push_str(&format!("**Priority**: {}\n\n", task.priority));

    if let Some(ref severity) = task.severity {
        context.push_str(&format!("**Severity**: {:?}\n\n", severity));
    }

    if let Some(ref impact) = task.impact {
        context.push_str(&format!("**Impact**: {:?}\n\n", impact));
    }

    context.push_str("## Description\n\n");
    context.push_str(&task.description);
    context.push_str("\n\n");

    if !task.dependencies.is_empty() {
        context.push_str("## Dependencies\n\n");
        for dep in &task.dependencies {
            context.push_str(&format!("- {}\n", dep));
        }
        context.push('\n');
    }

    if let Some(duration) = task.estimated_duration {
        context.push_str(&format!("**Estimated Duration**: {} minutes\n\n", duration));
    }

    context.push_str("## Instructions\n\n");
    context.push_str("Please implement the following:\n\n");
    context.push_str("1. Analyze the task requirements\n");
    context.push_str("2. Generate the necessary code changes\n");
    context.push_str("3. Create tests for the new functionality\n");
    context.push_str("4. Add documentation (Rustdoc comments)\n");
    context.push_str("5. Commit the changes with a descriptive message\n\n");

    context.push_str("---\n\n");
    context.push_str("*Generated by Miyabi CodeGenAgent*\n");

    context
}

/// Potpie 統合を利用した拡張版コンテキストを生成
#[allow(dead_code)] // 既存の呼び出し箇所が有効化されたら外す
pub async fn build_enhanced_execution_context(
    task: &Task,
    potpie_config: Option<PotpieConfig>,
) -> String {
    let mut context = build_execution_context(task);

    if let Some(config) = potpie_config {
        let potpie = PotpieIntegration::new(Some(config));

        if potpie.is_available().await {
            tracing::info!("Fetching existing implementations from Potpie");

            match potpie
                .find_existing_implementations(&task.description)
                .await
            {
                Ok(existing_code) if !existing_code.is_empty() => {
                    // Instructions セクションの直前に挿入
                    let instructions_marker = "## Instructions\n\n";
                    if let Some(pos) = context.find(instructions_marker) {
                        context.insert_str(pos, &existing_code);
                    } else {
                        let footer_marker = "---\n\n";
                        if let Some(pos) = context.find(footer_marker) {
                            context.insert_str(pos, &existing_code);
                        } else {
                            context.push_str(&existing_code);
                        }
                    }
                }
                Ok(_) => {
                    tracing::debug!("No existing implementations found");
                }
                Err(e) => {
                    tracing::warn!("Failed to fetch existing implementations: {}", e);
                }
            }
        } else {
            tracing::debug!("Potpie not available, using base context");
        }
    }

    context
}

/// Claude Code 用 .agent-context.json を生成
pub fn build_agent_context_json(config: &AgentConfig, task: &Task) -> Result<String, MiyabiError> {
    let context = serde_json::json!({
        "agentType": "CodeGenAgent",
        "agentStatus": "executing",
        "task": {
            "id": task.id,
            "title": task.title,
            "description": task.description,
            "taskType": task.task_type,
            "priority": task.priority,
            "severity": task.severity,
            "impact": task.impact,
            "dependencies": task.dependencies,
            "estimatedDuration": task.estimated_duration,
        },
        "config": {
            "useTaskTool": config.use_task_tool,
            "useWorktree": config.use_worktree,
        },
        "promptPath": ".claude/agents/prompts/coding/codegen-agent-prompt.md",
    });

    serde_json::to_string_pretty(&context)
        .map_err(|e| MiyabiError::Unknown(format!("Failed to serialize agent context: {}", e)))
}

/// タスク種別に応じたデフォルトファイル名を返す
pub fn determine_code_filename(task: &Task) -> String {
    match task.task_type {
        miyabi_types::task::TaskType::Feature => "src/feature.rs".to_string(),
        miyabi_types::task::TaskType::Bug => "src/fix.rs".to_string(),
        miyabi_types::task::TaskType::Refactor => "src/refactor.rs".to_string(),
        _ => "src/generated.rs".to_string(),
    }
}

/// ワークツリーへコンテキストファイルを書き出す
pub async fn write_context_files(
    worktree_path: &Path,
    config: &AgentConfig,
    task: &Task,
) -> Result<(), MiyabiError> {
    let context_md = build_execution_context(task);
    let context_path = worktree_path.join("EXECUTION_CONTEXT.md");
    tokio::fs::write(&context_path, context_md)
        .await
        .map_err(|e| {
            MiyabiError::Unknown(format!("Failed to write EXECUTION_CONTEXT.md: {}", e))
        })?;

    let context_json = build_agent_context_json(config, task)?;
    let json_path = worktree_path.join(".agent-context.json");
    tokio::fs::write(&json_path, context_json)
        .await
        .map_err(|e| MiyabiError::Unknown(format!("Failed to write .agent-context.json: {}", e)))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use miyabi_types::agent::{ImpactLevel, Severity};
    use miyabi_types::task::TaskType;
    use miyabi_types::{AgentConfig, Task};
    use std::time::{SystemTime, UNIX_EPOCH};

    fn test_config() -> AgentConfig {
        AgentConfig {
            device_identifier: "test-device".to_string(),
            github_token: "test-token".to_string(),
            repo_owner: Some("owner".to_string()),
            repo_name: Some("repo".to_string()),
            use_task_tool: false,
            use_worktree: false,
            worktree_base_path: None,
            log_directory: "./logs".to_string(),
            report_directory: "./reports".to_string(),
            tech_lead_github_username: None,
            ciso_github_username: None,
            po_github_username: None,
            firebase_production_project: None,
            firebase_staging_project: None,
            production_url: None,
            staging_url: None,
        }
    }

    fn sample_task() -> Task {
        let mut task = Task::new(
            "task-1".to_string(),
            "Implement new feature".to_string(),
            "Feature description".to_string(),
            TaskType::Feature,
            1,
        )
        .expect("valid task");
        task.dependencies = vec!["task-0".to_string()];
        task.severity = Some(Severity::High);
        task.impact = Some(ImpactLevel::High);
        task.estimated_duration = Some(45);
        task
    }

    #[test]
    fn execution_context_contains_sections() {
        let context = build_execution_context(&sample_task());

        assert!(context.contains("# Execution Context"));
        assert!(context.contains("**Task ID**: task-1"));
        assert!(context.contains("**Task Title**: Implement new feature"));
        assert!(context.contains("**Task Type**: Feature"));
        assert!(context.contains("**Priority**: 1"));
        assert!(context.contains("**Severity**: High"));
        assert!(context.contains("**Impact**: High"));
        assert!(context.contains("## Description"));
        assert!(context.contains("Feature description"));
        assert!(context.contains("## Dependencies"));
        assert!(context.contains("- task-0"));
        assert!(context.contains("**Estimated Duration**: 45 minutes"));
        assert!(context.contains("## Instructions"));
    }

    #[test]
    fn execution_context_handles_minimal_task() {
        let task = Task::new(
            "task-min".to_string(),
            "Minimal task".to_string(),
            "Just do it".to_string(),
            TaskType::Docs,
            3,
        )
        .expect("valid task");

        let context = build_execution_context(&task);

        assert!(context.contains("**Task ID**: task-min"));
        assert!(context.contains("**Task Title**: Minimal task"));
        assert!(!context.contains("**Severity**:"));
        assert!(!context.contains("**Impact**:"));
        assert!(!context.contains("## Dependencies"));
    }

    #[test]
    fn agent_context_json_serializes_task() {
        let config = test_config();
        let task = sample_task();

        let json_str = build_agent_context_json(&config, &task).expect("json");
        let json: serde_json::Value = serde_json::from_str(&json_str).expect("valid json");

        assert_eq!(json["agentType"], "CodeGenAgent");
        assert_eq!(json["agentStatus"], "executing");
        assert_eq!(json["task"]["id"], "task-1");
        assert_eq!(json["task"]["title"], "Implement new feature");
        assert_eq!(json["task"]["taskType"], "feature");
        assert_eq!(json["task"]["priority"], 1);
        assert_eq!(json["task"]["severity"], "Sev.2-High");
        assert_eq!(json["task"]["impact"], "High");
        assert_eq!(json["task"]["dependencies"][0], "task-0");
        assert_eq!(json["task"]["estimatedDuration"], 45);
        assert_eq!(
            json["promptPath"],
            ".claude/agents/prompts/coding/codegen-agent-prompt.md"
        );
    }

    #[test]
    fn determine_filename_by_task_type() {
        let mut task = sample_task();
        task.task_type = TaskType::Feature;
        assert_eq!(determine_code_filename(&task), "src/feature.rs");

        task.task_type = TaskType::Bug;
        assert_eq!(determine_code_filename(&task), "src/fix.rs");

        task.task_type = TaskType::Refactor;
        assert_eq!(determine_code_filename(&task), "src/refactor.rs");

        task.task_type = TaskType::Deployment;
        assert_eq!(determine_code_filename(&task), "src/generated.rs");
    }

    #[tokio::test]
    async fn write_context_files_creates_outputs() {
        let config = test_config();
        let task = sample_task();

        let unique = format!(
            "miyabi-context-test-{}-{}",
            std::process::id(),
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .expect("time")
                .as_nanos()
        );
        let temp_dir = std::env::temp_dir().join(unique);
        tokio::fs::create_dir_all(&temp_dir)
            .await
            .expect("create temp dir");

        write_context_files(&temp_dir, &config, &task)
            .await
            .expect("write files");

        assert!(temp_dir.join("EXECUTION_CONTEXT.md").exists());
        assert!(temp_dir.join(".agent-context.json").exists());

        tokio::fs::remove_dir_all(&temp_dir)
            .await
            .expect("cleanup temp dir");
    }
}
