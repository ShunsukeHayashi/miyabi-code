//! Persistence traits for business agents
//!
//! Issue: #1173 - Business Agent Database Persistence Integration
//!
//! This module provides the `PersistableAgent` trait that enables business agents
//! to persist their execution results to the database.

use async_trait::async_trait;
use miyabi_types::{AgentResult, AgentType};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Execution metadata for persistence
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ExecutionMetadata {
    /// User ID who triggered the execution
    pub user_id: Option<Uuid>,
    /// Repository ID associated with the execution
    pub repository_id: Option<Uuid>,
    /// Issue number associated with the execution
    pub issue_number: Option<i32>,
    /// Additional context for the execution
    pub context: Option<serde_json::Value>,
}

impl ExecutionMetadata {
    /// Create new execution metadata with user ID
    pub fn with_user_id(user_id: Uuid) -> Self {
        Self {
            user_id: Some(user_id),
            ..Default::default()
        }
    }

    /// Set repository ID
    pub fn with_repository_id(mut self, repository_id: Uuid) -> Self {
        self.repository_id = Some(repository_id);
        self
    }

    /// Set issue number
    pub fn with_issue_number(mut self, issue_number: i32) -> Self {
        self.issue_number = Some(issue_number);
        self
    }

    /// Set context
    pub fn with_context(mut self, context: serde_json::Value) -> Self {
        self.context = Some(context);
        self
    }
}

/// Analytics data for business agent executions
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct BusinessAnalytics {
    /// Generic metrics stored as JSON
    pub metrics: serde_json::Value,

    // Market research specific
    pub competitors_analyzed: Option<i32>,
    pub market_size_usd: Option<i64>,
    pub growth_rate_percent: Option<f64>,

    // Sales/Marketing specific
    pub conversion_rate: Option<f64>,
    pub target_audience_size: Option<i32>,
    pub estimated_revenue_usd: Option<i64>,

    // Content/Analytics specific
    pub engagement_score: Option<i32>,
    pub reach_estimate: Option<i32>,
    pub roi_percent: Option<f64>,
}

impl BusinessAnalytics {
    /// Create new business analytics with metrics
    pub fn with_metrics(metrics: serde_json::Value) -> Self {
        Self {
            metrics,
            ..Default::default()
        }
    }

    /// Set market research metrics
    pub fn with_market_research(
        mut self,
        competitors: i32,
        market_size: i64,
        growth_rate: f64,
    ) -> Self {
        self.competitors_analyzed = Some(competitors);
        self.market_size_usd = Some(market_size);
        self.growth_rate_percent = Some(growth_rate);
        self
    }

    /// Set sales metrics
    pub fn with_sales_metrics(
        mut self,
        conversion_rate: f64,
        audience_size: i32,
        revenue: i64,
    ) -> Self {
        self.conversion_rate = Some(conversion_rate);
        self.target_audience_size = Some(audience_size);
        self.estimated_revenue_usd = Some(revenue);
        self
    }

    /// Set content metrics
    pub fn with_content_metrics(mut self, engagement: i32, reach: i32, roi: f64) -> Self {
        self.engagement_score = Some(engagement);
        self.reach_estimate = Some(reach);
        self.roi_percent = Some(roi);
        self
    }
}

/// Persistable execution result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistableResult {
    /// Execution ID (generated by persistence layer if not provided)
    pub execution_id: Option<Uuid>,
    /// Agent type
    pub agent_type: AgentType,
    /// Execution status
    pub status: ExecutionStatus,
    /// Result data
    pub result: AgentResult,
    /// Execution metadata
    pub metadata: ExecutionMetadata,
    /// Business analytics (optional)
    pub analytics: Option<BusinessAnalytics>,
    /// Error message (if failed)
    pub error_message: Option<String>,
    /// Quality score (0-100)
    pub quality_score: Option<i32>,
}

/// Execution status for persistence
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ExecutionStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

impl std::fmt::Display for ExecutionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExecutionStatus::Pending => write!(f, "pending"),
            ExecutionStatus::Running => write!(f, "running"),
            ExecutionStatus::Completed => write!(f, "completed"),
            ExecutionStatus::Failed => write!(f, "failed"),
            ExecutionStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

impl From<miyabi_types::agent::ResultStatus> for ExecutionStatus {
    fn from(status: miyabi_types::agent::ResultStatus) -> Self {
        match status {
            miyabi_types::agent::ResultStatus::Success => ExecutionStatus::Completed,
            miyabi_types::agent::ResultStatus::Failed => ExecutionStatus::Failed,
            miyabi_types::agent::ResultStatus::Escalated => ExecutionStatus::Failed,
        }
    }
}

/// Trait for agents that can persist their results to database
///
/// Business agents implement this trait to enable automatic persistence
/// of execution results, logs, and analytics to PostgreSQL.
#[async_trait]
pub trait PersistableAgent: Send + Sync {
    /// Get the agent type for persistence
    fn persistable_agent_type(&self) -> AgentType;

    /// Extract analytics data from the agent result
    ///
    /// Override this method to provide custom analytics extraction
    fn extract_analytics(&self, result: &AgentResult) -> Option<BusinessAnalytics> {
        // Default implementation extracts generic metrics
        result
            .data
            .as_ref()
            .map(|data| BusinessAnalytics::with_metrics(data.clone()))
    }

    /// Get the quality score from the result
    fn get_quality_score(&self, result: &AgentResult) -> Option<i32> {
        result
            .metrics
            .as_ref()
            .and_then(|m| m.quality_score.map(|s| s as i32))
    }

    /// Convert agent result to persistable result
    fn to_persistable_result(
        &self,
        result: AgentResult,
        metadata: ExecutionMetadata,
    ) -> PersistableResult {
        let status = result.status.into();
        let analytics = self.extract_analytics(&result);
        let quality_score = self.get_quality_score(&result);
        let error_message = result.error.clone();

        PersistableResult {
            execution_id: None,
            agent_type: self.persistable_agent_type(),
            status,
            result,
            metadata,
            analytics,
            error_message,
            quality_score,
        }
    }
}

/// Extension trait to make any BaseAgent persistable with default implementation
#[async_trait]
impl<T> PersistableAgent for T
where
    T: super::BaseAgent,
{
    fn persistable_agent_type(&self) -> AgentType {
        self.agent_type()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_execution_metadata_builder() {
        let user_id = Uuid::new_v4();
        let repo_id = Uuid::new_v4();

        let metadata = ExecutionMetadata::with_user_id(user_id)
            .with_repository_id(repo_id)
            .with_issue_number(123);

        assert_eq!(metadata.user_id, Some(user_id));
        assert_eq!(metadata.repository_id, Some(repo_id));
        assert_eq!(metadata.issue_number, Some(123));
    }

    #[test]
    fn test_business_analytics_builder() {
        let analytics = BusinessAnalytics::with_metrics(serde_json::json!({"test": true}))
            .with_market_research(10, 1_000_000, 15.5)
            .with_sales_metrics(0.25, 50000, 500000);

        assert_eq!(analytics.competitors_analyzed, Some(10));
        assert_eq!(analytics.market_size_usd, Some(1_000_000));
        assert_eq!(analytics.conversion_rate, Some(0.25));
    }

    #[test]
    fn test_execution_status_display() {
        assert_eq!(ExecutionStatus::Pending.to_string(), "pending");
        assert_eq!(ExecutionStatus::Running.to_string(), "running");
        assert_eq!(ExecutionStatus::Completed.to_string(), "completed");
        assert_eq!(ExecutionStatus::Failed.to_string(), "failed");
    }

    #[test]
    fn test_execution_status_from_result_status() {
        use miyabi_types::agent::ResultStatus;

        assert_eq!(
            ExecutionStatus::from(ResultStatus::Success),
            ExecutionStatus::Completed
        );
        assert_eq!(
            ExecutionStatus::from(ResultStatus::Failed),
            ExecutionStatus::Failed
        );
        assert_eq!(
            ExecutionStatus::from(ResultStatus::Escalated),
            ExecutionStatus::Failed
        );
    }
}
