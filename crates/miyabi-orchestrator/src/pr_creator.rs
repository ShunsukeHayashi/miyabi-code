//! Pull Request creation from multiple worktrees

use crate::aggregator::AggregatedResult;
use crate::error::{Result, SchedulerError};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::process::Stdio;
use tokio::process::Command;
use tracing::{debug, info, warn};

/// Pull Request metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequest {
    /// PR number
    pub number: u64,
    /// PR title
    pub title: String,
    /// PR body
    pub body: String,
    /// Source branch
    pub branch: String,
    /// Target branch
    pub base_branch: String,
    /// PR URL
    pub url: String,
}

/// PR creation configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PRConfig {
    /// Repository owner
    pub owner: String,
    /// Repository name
    pub repo: String,
    /// Base branch for PRs (default: "main")
    pub base_branch: String,
    /// Draft PR (default: false)
    pub draft: bool,
}

impl Default for PRConfig {
    fn default() -> Self {
        Self {
            owner: String::new(),
            repo: String::new(),
            base_branch: "main".to_string(),
            draft: false,
        }
    }
}

/// Pull Request creator for aggregated worktree results
pub struct PRCreator {
    /// PR configuration
    config: PRConfig,
}

impl PRCreator {
    /// Create a new PRCreator
    ///
    /// # Arguments
    ///
    /// * `config` - PR configuration
    pub fn new(config: PRConfig) -> Self {
        Self { config }
    }

    /// Create a PR from aggregated results
    ///
    /// # Arguments
    ///
    /// * `branch_name` - Branch name for the PR
    /// * `title` - PR title
    /// * `result` - Aggregated result from multiple sessions
    ///
    /// # Returns
    ///
    /// Returns the created `PullRequest`
    ///
    /// # Errors
    ///
    /// Returns error if PR creation fails
    pub async fn create_pr(
        &self,
        branch_name: String,
        title: String,
        result: &AggregatedResult,
    ) -> Result<PullRequest> {
        info!("Creating PR: {} from branch {}", title, branch_name);

        // Generate PR body from aggregated result
        let body = self.generate_pr_body(result);

        // Create PR using GitHub CLI
        let pr_url = self.create_pr_via_gh(&branch_name, &title, &body).await?;

        // Extract PR number from URL
        let pr_number = self.extract_pr_number(&pr_url)?;

        let pr = PullRequest {
            number: pr_number,
            title: title.clone(),
            body,
            branch: branch_name,
            base_branch: self.config.base_branch.clone(),
            url: pr_url,
        };

        info!("PR created: #{} at {}", pr.number, pr.url);

        Ok(pr)
    }

    /// Generate PR body from aggregated result
    pub fn generate_pr_body(&self, result: &AggregatedResult) -> String {
        let mut body = String::new();

        // Summary section
        body.push_str("## Summary\n\n");
        body.push_str(&format!("{}\n\n", result.summary()));

        // Statistics section
        body.push_str("## Statistics\n\n");
        body.push_str(&format!("- Total sessions: {}\n", result.total_sessions));
        body.push_str(&format!("- Successful: {}\n", result.successful_sessions));
        body.push_str(&format!("- Failed: {}\n", result.failed_sessions));
        body.push_str(&format!("- Success rate: {:.1}%\n\n", result.success_rate * 100.0));

        // Modified files section
        if !result.modified_files.is_empty() {
            body.push_str("## Modified Files\n\n");
            for file in &result.modified_files {
                body.push_str(&format!("- `{}`\n", file));
            }
            body.push('\n');
        }

        // Errors section (if any)
        if !result.errors.is_empty() {
            body.push_str("## Errors\n\n");
            for error in &result.errors {
                body.push_str(&format!("- {}\n", error));
            }
            body.push('\n');
        }

        // Footer
        body.push_str("---\n\n");
        body.push_str("ðŸ¤– Generated by Water Spider Orchestrator\n");

        body
    }

    /// Create PR via GitHub CLI
    async fn create_pr_via_gh(&self, branch: &str, title: &str, body: &str) -> Result<String> {
        debug!("Executing gh pr create");

        let mut cmd = Command::new("gh");
        cmd.arg("pr")
            .arg("create")
            .arg("--title")
            .arg(title)
            .arg("--body")
            .arg(body)
            .arg("--base")
            .arg(&self.config.base_branch)
            .arg("--head")
            .arg(branch);

        if self.config.draft {
            cmd.arg("--draft");
        }

        let output = cmd
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(SchedulerError::SpawnFailed)?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("PR creation failed: {}", stderr);
            return Err(SchedulerError::ProcessFailed {
                code: output.status.code().unwrap_or(-1),
                stderr: stderr.to_string(),
            });
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let pr_url = stdout.trim().to_string();

        Ok(pr_url)
    }

    /// Extract PR number from URL
    fn extract_pr_number(&self, url: &str) -> Result<u64> {
        // URL format: https://github.com/owner/repo/pull/123
        let parts: Vec<&str> = url.split('/').collect();
        if let Some(number_str) = parts.last() {
            number_str
                .parse::<u64>()
                .map_err(|_| SchedulerError::InvalidConfig(format!("Invalid PR URL: {}", url)))
        } else {
            Err(SchedulerError::InvalidConfig(format!("Invalid PR URL: {}", url)))
        }
    }

    /// Merge multiple worktrees into a single branch
    ///
    /// # Arguments
    ///
    /// * `worktrees` - List of worktree paths
    /// * `target_branch` - Target branch name
    ///
    /// # Returns
    ///
    /// Returns Ok if merge succeeds
    ///
    /// # Errors
    ///
    /// Returns error if merge fails
    pub async fn merge_worktrees(
        &self,
        worktrees: Vec<PathBuf>,
        target_branch: String,
    ) -> Result<()> {
        info!("Merging {} worktrees into branch {}", worktrees.len(), target_branch);

        // Create target branch
        self.create_branch(&target_branch).await?;

        // Merge each worktree
        for worktree in &worktrees {
            self.merge_worktree(worktree, &target_branch).await?;
        }

        info!("All worktrees merged into {}", target_branch);

        Ok(())
    }

    /// Create a new branch
    async fn create_branch(&self, branch_name: &str) -> Result<()> {
        debug!("Creating branch: {}", branch_name);

        let output = Command::new("git")
            .arg("checkout")
            .arg("-b")
            .arg(branch_name)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(SchedulerError::SpawnFailed)?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            // Branch might already exist, try to switch to it
            if stderr.contains("already exists") {
                return self.switch_branch(branch_name).await;
            }
            return Err(SchedulerError::ProcessFailed {
                code: output.status.code().unwrap_or(-1),
                stderr: stderr.to_string(),
            });
        }

        Ok(())
    }

    /// Switch to an existing branch
    async fn switch_branch(&self, branch_name: &str) -> Result<()> {
        debug!("Switching to branch: {}", branch_name);

        let output = Command::new("git")
            .arg("checkout")
            .arg(branch_name)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(SchedulerError::SpawnFailed)?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(SchedulerError::ProcessFailed {
                code: output.status.code().unwrap_or(-1),
                stderr: stderr.to_string(),
            });
        }

        Ok(())
    }

    /// Merge a worktree into the current branch
    async fn merge_worktree(&self, worktree: &PathBuf, _target_branch: &str) -> Result<()> {
        debug!("Merging worktree: {}", worktree.display());

        // Get worktree branch name
        let branch_name = self.get_worktree_branch(worktree).await?;

        // Merge the branch
        let output = Command::new("git")
            .arg("merge")
            .arg("--no-ff")
            .arg(&branch_name)
            .arg("-m")
            .arg(format!("Merge worktree {}", worktree.display()))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(SchedulerError::SpawnFailed)?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("Merge failed for {}: {}", worktree.display(), stderr);
            return Err(SchedulerError::ProcessFailed {
                code: output.status.code().unwrap_or(-1),
                stderr: stderr.to_string(),
            });
        }

        Ok(())
    }

    /// Get branch name for a worktree
    async fn get_worktree_branch(&self, worktree: &PathBuf) -> Result<String> {
        let output = Command::new("git")
            .arg("-C")
            .arg(worktree)
            .arg("rev-parse")
            .arg("--abbrev-ref")
            .arg("HEAD")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(SchedulerError::SpawnFailed)?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(SchedulerError::ProcessFailed {
                code: output.status.code().unwrap_or(-1),
                stderr: stderr.to_string(),
            });
        }

        let branch_name = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(branch_name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::aggregator::AggregatedResult;
    use crate::parser::AgentResult;
    use std::collections::HashMap;

    fn create_test_config() -> PRConfig {
        PRConfig {
            owner: "test-owner".to_string(),
            repo: "test-repo".to_string(),
            base_branch: "main".to_string(),
            draft: false,
        }
    }

    fn create_test_result() -> AggregatedResult {
        let mut session_results = HashMap::new();
        session_results.insert(
            "session-1".to_string(),
            AgentResult {
                status: 0,
                success: true,
                message: "Success".to_string(),
                error: None,
                files: vec!["file1.rs".to_string()],
            },
        );

        AggregatedResult {
            total_sessions: 1,
            successful_sessions: 1,
            failed_sessions: 0,
            success_rate: 1.0,
            session_results,
            errors: vec![],
            modified_files: vec!["file1.rs".to_string()],
        }
    }

    #[test]
    fn test_pr_creator_creation() {
        let config = create_test_config();
        let creator = PRCreator::new(config);
        assert_eq!(creator.config.owner, "test-owner");
    }

    #[test]
    fn test_generate_pr_body() {
        let config = create_test_config();
        let creator = PRCreator::new(config);
        let result = create_test_result();

        let body = creator.generate_pr_body(&result);
        assert!(body.contains("Summary"));
        assert!(body.contains("Statistics"));
        assert!(body.contains("Modified Files"));
        assert!(body.contains("file1.rs"));
        assert!(body.contains("Water Spider Orchestrator"));
    }

    #[test]
    fn test_generate_pr_body_with_errors() {
        let config = create_test_config();
        let creator = PRCreator::new(config);
        let mut result = create_test_result();
        result.errors.push("Test error".to_string());

        let body = creator.generate_pr_body(&result);
        assert!(body.contains("Errors"));
        assert!(body.contains("Test error"));
    }

    #[test]
    fn test_extract_pr_number() {
        let config = create_test_config();
        let creator = PRCreator::new(config);

        let url = "https://github.com/owner/repo/pull/123";
        let number = creator.extract_pr_number(url).unwrap();
        assert_eq!(number, 123);
    }

    #[test]
    fn test_extract_pr_number_invalid() {
        let config = create_test_config();
        let creator = PRCreator::new(config);

        let url = "https://github.com/owner/repo";
        let result = creator.extract_pr_number(url);
        assert!(result.is_err());
    }
}
