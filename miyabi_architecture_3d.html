<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Miyabi System: OVERDRIVE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Rajdhani', sans-serif; }
        /* Import a cool sci-fi font */
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        h1 {
            margin: 0;
            font-size: 3rem;
            color: #fff;
            text-shadow: 0 0 20px #00ffcc;
            letter-spacing: 5px;
            font-weight: 700;
        }

        .subtitle {
            color: #00ffcc;
            font-size: 1.2rem;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        .stats {
            text-align: right;
            color: #ff0055;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            line-height: 1.5;
        }

        #center-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        #counter {
            font-size: 12vw;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.05);
            -webkit-text-stroke: 2px rgba(0, 255, 204, 0.5);
            text-shadow: 0 0 50px rgba(0, 255, 204, 0.8);
            display: none;
        }

        #status-msg {
            font-size: 2rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 30px;
            border: 1px solid #00ffcc;
            margin-top: 20px;
            display: inline-block;
            opacity: 0;
            transition: opacity 0.3s;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #controls {
            pointer-events: auto;
            text-align: center;
            margin-bottom: 50px;
        }

        button {
            background: transparent;
            border: 2px solid #ff0055;
            color: #ff0055;
            padding: 20px 60px;
            font-size: 1.5rem;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            letter-spacing: 5px;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: #ff0055;
            transition: 0.3s;
            z-index: -1;
        }

        button:hover::before {
            left: 0;
        }

        button:hover {
            color: #fff;
            box-shadow: 0 0 50px #ff0055;
        }

        .scanline {
            width: 100%;
            height: 5px;
            background: rgba(0, 255, 204, 0.1);
            position: fixed;
            top: 0;
            animation: scan 3s linear infinite;
            pointer-events: none;
            z-index: 999;
        }
        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

    </style>
</head>
<body>

<div class="scanline"></div>

<div id="hud">
    <div class="header">
        <div>
            <h1>MIYABI</h1>
            <div class="subtitle">AUTONOMOUS AGENT ORCHESTRATION SYSTEM</div>
        </div>
        <div class="stats">
            <div>CPU: <span id="cpu-stat">NORMAL</span></div>
            <div>MEM: <span id="mem-stat">OPTIMAL</span></div>
            <div>NET: <span id="net-stat">SECURE</span></div>
        </div>
    </div>

    <div id="center-overlay">
        <div id="counter">0</div>
        <div id="status-msg">SYSTEM READY</div>
    </div>

    <div id="controls">
        <button id="ignite-btn">EXECUTE OVERDRIVE</button>
    </div>
</div>

<!-- Import Three.js -->
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

    // --- SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205);
    scene.fog = new THREE.FogExp2(0x020205, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 30, 120);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.2;
    controls.maxDistance = 500;

    // --- POST PROCESSING ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Bloom - More intense
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.5, 0.1);
    composer.addPass(bloomPass);

    // Glitch - Triggered on command
    const glitchPass = new GlitchPass();
    glitchPass.goWild = false;
    glitchPass.enabled = false;
    composer.addPass(glitchPass);

    const outputPass = new OutputPass();
    composer.addPass(outputPass);


    // --- WORLD BUILDING ---

    // 1. Infinite Grid
    const gridHelper = new THREE.GridHelper(2000, 200, 0x111122, 0x050510);
    gridHelper.position.y = -50;
    scene.add(gridHelper);

    // 2. Starfield / Data Cloud
    const starsGeo = new THREE.BufferGeometry();
    const starsCount = 5000;
    const starsPos = new Float32Array(starsCount * 3);
    for(let i=0; i<starsCount*3; i++) {
        starsPos[i] = (Math.random() - 0.5) * 1000;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
    const starsMat = new THREE.PointsMaterial({color: 0x4444aa, size: 0.5, transparent: true, opacity: 0.5});
    const stars = new THREE.Points(starsGeo, starsMat);
    scene.add(stars);


    // --- NODES ---
    const nodes = {
        guardian: { y: 60, color: 0xff0044, label: "GUARDIAN", size: 5 },
        maestro: { y: 30, color: 0xffaa00, label: "MAESTRO", size: 4 },
        orchestrator: { y: 5, color: 0x00ccff, label: "ORCHESTRATOR", size: 4 },
        coordinator: { y: -20, color: 0xaa00ff, label: "COORDINATOR", size: 5 }
    };

    const nodeMeshes = {};

    Object.keys(nodes).forEach(key => {
        const n = nodes[key];
        
        // Core
        const geo = new THREE.IcosahedronGeometry(n.size, 1);
        const mat = new THREE.MeshBasicMaterial({ color: n.color, wireframe: true });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = n.y;
        
        // Inner light
        const lightGeo = new THREE.IcosahedronGeometry(n.size * 0.6, 0);
        const lightMat = new THREE.MeshBasicMaterial({ color: n.color });
        const light = new THREE.Mesh(lightGeo, lightMat);
        mesh.add(light);

        // Orbital Rings
        const ringGeo = new THREE.TorusGeometry(n.size * 2.5, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: n.color, transparent: true, opacity: 0.3 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI/2;
        mesh.add(ring);

        scene.add(mesh);
        nodeMeshes[key] = mesh;
    });

    // --- DATA STREAMS (The Connection) ---
    const streamCount = 20; // Multiple lines for heavy data look
    const streamGeo = new THREE.BufferGeometry();
    const streamPos = new Float32Array(streamCount * 2 * 3); // 2 points per line
    streamGeo.setAttribute('position', new THREE.BufferAttribute(streamPos, 3));
    const streamMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
    const streamLines = new THREE.LineSegments(streamGeo, streamMat);
    streamLines.frustumCulled = false; // Always render
    scene.add(streamLines);


    // --- THE SWARM (250M AGENTS) ---
    const swarmCount = 40000; // Limit for browser capability, represents the mass
    const swarmGeo = new THREE.BufferGeometry();
    const swarmPos = new Float32Array(swarmCount * 3);
    const swarmColors = new Float32Array(swarmCount * 3);
    
    const color1 = new THREE.Color(0x00ffcc); // Coder
    const color2 = new THREE.Color(0xff0055); // Strategy
    const color3 = new THREE.Color(0xffee00); // Business

    for(let i=0; i<swarmCount; i++) {
        const i3 = i * 3;
        // Start hidden at coordinator
        swarmPos[i3] = 0;
        swarmPos[i3+1] = nodes.coordinator.y;
        swarmPos[i3+2] = 0;

        // Mix colors
        const type = Math.random();
        let c;
        if(type < 0.6) c = color1;
        else if(type < 0.8) c = color2;
        else c = color3;

        swarmColors[i3] = c.r;
        swarmColors[i3+1] = c.g;
        swarmColors[i3+2] = c.b;
    }

    swarmGeo.setAttribute('position', new THREE.BufferAttribute(swarmPos, 3));
    swarmGeo.setAttribute('color', new THREE.BufferAttribute(swarmColors, 3));

    const swarmMat = new THREE.PointsMaterial({
        size: 0.6,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const swarm = new THREE.Points(swarmGeo, swarmMat);
    swarm.visible = false;
    scene.add(swarm);

    // --- SHOCKWAVE RING ---
    const shockGeo = new THREE.RingGeometry(1, 2, 64);
    const shockMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const shockwave = new THREE.Mesh(shockGeo, shockMat);
    shockwave.rotation.x = Math.PI / 2;
    shockwave.position.y = nodes.coordinator.y;
    scene.add(shockwave);


    // --- ANIMATION LOGIC ---
    let state = 'IDLE'; // IDLE, CHARGING, FIRING, DEPLOYING
    let progress = 0;
    const targetSwarmPositions = []; // Calculated on init

    // Pre-calculate swarm explosion targets (Spiral Galaxy shape)
    for(let i=0; i<swarmCount; i++) {
        const radius = 50 + Math.random() * 200;
        const angle = Math.random() * Math.PI * 2 * 5; // Multiple winds
        const h = (Math.random() - 0.5) * 100;
        
        targetSwarmPositions.push({
            x: radius * Math.cos(angle),
            y: nodes.coordinator.y + h,
            z: radius * Math.sin(angle)
        });
    }

    // Camera Shake
    function shakeCamera(intensity) {
        camera.position.x += (Math.random() - 0.5) * intensity;
        camera.position.y += (Math.random() - 0.5) * intensity;
        camera.position.z += (Math.random() - 0.5) * intensity;
    }


    document.getElementById('ignite-btn').addEventListener('click', () => {
        if(state !== 'IDLE') return;
        
        state = 'CHARGING';
        progress = 0;
        
        document.getElementById('ignite-btn').style.opacity = 0;
        document.getElementById('status-msg').innerText = "SYNCING NEURAL LINK...";
        document.getElementById('status-msg').style.opacity = 1;

        // Sound effect visualization (Camera Zoom)
        const targetPos = new THREE.Vector3(0, 30, 80);
        const interval = setInterval(() => {
            camera.position.lerp(targetPos, 0.05);
            if(camera.position.distanceTo(targetPos) < 1) clearInterval(interval);
        }, 16);
    });


    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;

        // 1. Idle Animation
        Object.keys(nodeMeshes).forEach((k, idx) => {
            const m = nodeMeshes[k];
            m.rotation.y = time * (0.5 + idx * 0.1);
            m.rotation.z = Math.sin(time + idx) * 0.2;
            // Floating
            m.position.y = nodes[k].y + Math.sin(time * 2 + idx) * 0.5;
        });
        
        stars.rotation.y = time * 0.02;

        // 2. State Machine
        if (state === 'CHARGING') {
            progress += 0.01;
            shakeCamera(0.2);
            
            // Gather energy at Guardian
            nodeMeshes.guardian.scale.setScalar(1 + Math.sin(time * 20) * 0.2);
            nodeMeshes.guardian.material.color.setHex(0xffffff); // Flash white

            if (progress > 1) {
                state = 'FIRING';
                progress = 0;
                document.getElementById('status-msg').innerText = "TRANSMITTING WILL";
                glitchPass.enabled = true; // Glitch on fire
                setTimeout(() => glitchPass.enabled = false, 200);
            }
        }

        if (state === 'FIRING') {
            progress += 0.05;
            shakeCamera(0.5);

            // Draw beams cascading down
            const positions = streamLines.geometry.attributes.position.array;
            const keys = ['guardian', 'maestro', 'orchestrator', 'coordinator'];
            
            // Simple cascading logic
            let currentTargetIdx = Math.floor(progress * 3); 
            if(currentTargetIdx > 2) currentTargetIdx = 2;

            const startNode = nodeMeshes[keys[currentTargetIdx]];
            const endNode = nodeMeshes[keys[currentTargetIdx+1]];

            // Randomize beam paths slightly
            for(let i=0; i<streamCount; i++) {
                const offset = (Math.random() - 0.5) * 2;
                positions[i*6] = startNode.position.x + offset;
                positions[i*6+1] = startNode.position.y;
                positions[i*6+2] = startNode.position.z + offset;

                positions[i*6+3] = endNode.position.x + offset;
                positions[i*6+4] = endNode.position.y;
                positions[i*6+5] = endNode.position.z + offset;
            }
            streamLines.geometry.attributes.position.needsUpdate = true;
            
            if (progress > 1.5) { // Give it some time to reach bottom
                state = 'DEPLOYING';
                progress = 0;
                streamLines.visible = false; // beams gone
                swarm.visible = true;
                shockwave.visible = true;
                shockMat.opacity = 1;
                
                document.getElementById('status-msg').innerText = "SWARM AWAKENED";
                document.getElementById('counter').style.display = 'block';
                
                // Big impact shake
                shakeCamera(5);
            }
        }

        if (state === 'DEPLOYING') {
            progress += 0.008;
            
            // Expand Shockwave
            const shockScale = 1 + progress * 200;
            shockwave.scale.set(shockScale, shockScale, 1);
            shockMat.opacity = 1 - progress;

            // Move Particles
            const pos = swarm.geometry.attributes.position.array;
            
            // Easing: elastic out
            // const t = progress; 
            // Simple lerp for now but with swirl
            
            for(let i=0; i<swarmCount; i++) {
                const i3 = i * 3;
                const tx = targetSwarmPositions[i].x;
                const ty = targetSwarmPositions[i].y;
                const tz = targetSwarmPositions[i].z;
                
                // Add spiral movement
                const angle = time + i * 0.0001;
                const radiusExp = progress * 1.5; // Expansion factor

                pos[i3] = pos[i3] + (tx - pos[i3]) * 0.05;
                pos[i3+1] = pos[i3+1] + (ty - pos[i3+1]) * 0.05;
                pos[i3+2] = pos[i3+2] + (tz - pos[i3+2]) * 0.05;
            }
            swarm.geometry.attributes.position.needsUpdate = true;
            
            // Rotate entire swarm
            swarm.rotation.y = -time * 0.5;

            // Update counter
            const count = Math.floor(250000000 * Math.min(progress * 1.2, 1));
            if(count <= 250000000) {
                document.getElementById('counter').innerText = count.toLocaleString();
            } else {
                 document.getElementById('counter').innerText = "250,000,000";
                 document.getElementById('status-msg').innerText = "WORLD DOMINATION: ACTIVE";
            }

            controls.autoRotateSpeed = 1.0;
        }

        controls.update();
        composer.render();
    }
    
    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>

</body>
</html>