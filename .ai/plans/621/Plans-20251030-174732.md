# Plans for Issue #621

**Title**: feat: Web Dashboard 3Då¯è¦–åŒ– - Three.jsçµ±åˆ

**URL**: https://github.com/customer-cloud/miyabi-private/issues/621

---

## ğŸ“‹ Summary

- **Total Tasks**: 4
- **Estimated Duration**: 60 minutes
- **Execution Levels**: 4
- **Has Cycles**: âœ… No

## ğŸ“ Task Breakdown

### 1. Analyze requirements for #621

- **ID**: `task-621-analysis`
- **Type**: Docs
- **Assigned Agent**: IssueAgent
- **Priority**: 0
- **Estimated Duration**: 5 min

**Description**: Analyze issue requirements and create detailed specification

### 2. Implement solution for #621

- **ID**: `task-621-impl`
- **Type**: Feature
- **Assigned Agent**: CodeGenAgent
- **Priority**: 1
- **Estimated Duration**: 30 min
- **Dependencies**: task-621-analysis

**Description**: # Web Dashboard 3Då¯è¦–åŒ–

**Parent Issue**: #612 (Epic: KAMUI 4Dè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³çµ±åˆ)
**Phase**: Phase 3 - KAMUI 4Dçµ±åˆ
**Priority**: ğŸ“ P3-Low
**Estimated Time**: 10-14 days

## ğŸ“‹ æ¦‚è¦

Miyabi Web Dashboard (`miyabi-dashboard/`) ã«Three.jsãƒ™ãƒ¼ã‚¹ã®3Då¯è¦–åŒ–æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã€Entity-Relationãƒ¢ãƒ‡ãƒ«ã€WorktreeçŠ¶æ…‹ã€Agentå®Ÿè¡ŒçŠ¶æ³ã‚’3Dç©ºé–“ã§è¡¨ç¤ºã™ã‚‹ã€‚KAMUI 4Dã®3D Force Graphã‚’å‚è€ƒã«å®Ÿè£…ã€‚

## ğŸ¯ ç›®æ¨™

`miyabi dashboard` ã‚³ãƒãƒ³ãƒ‰ã§Webã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»¥ä¸‹ã‚’3Dè¡¨ç¤ºï¼š

- Entity-Relationãƒ¢ãƒ‡ãƒ«ã®3Dã‚°ãƒ©ãƒ•ï¼ˆ12 Entities, 27 Relationsï¼‰
- WorktreeçŠ¶æ…‹ã®è¦–è¦šåŒ–
- Agentå®Ÿè¡ŒçŠ¶æ³ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
- Gitã‚°ãƒ©ãƒ•ã®3Dè¡¨ç¤º

## ğŸ“Š è¦ä»¶

### å¿…é ˆè¦ä»¶

- [ ] Three.js + 3D Force Graphã®çµ±åˆ
- [ ] Entity-Relationãƒ¢ãƒ‡ãƒ«ã®3Dæç”»
  - 12å€‹ã®Entityã‚’ãƒãƒ¼ãƒ‰ã¨ã—ã¦è¡¨ç¤º
  - 27å€‹ã®Relationã‚’ã‚¨ãƒƒã‚¸ã¨ã—ã¦è¡¨ç¤º
  - ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯ã§è©³ç´°è¡¨ç¤º
- [ ] WorktreeçŠ¶æ…‹ã®å¯è¦–åŒ–
  - Active/Idle/OrphanedçŠ¶æ…‹ã‚’è‰²åˆ†ã‘
  - ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨é‡ã§ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã‚’å¤‰æ›´
- [ ] Agentå®Ÿè¡ŒçŠ¶æ³
  - å®Ÿè¡Œä¸­Agentã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  - é€²æ—ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º
- [ ] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ“ä½œ
  - ã‚ºãƒ¼ãƒ ã€å›è»¢ã€ãƒ‘ãƒ³
  - ãƒãƒ¼ãƒ‰é¸æŠã€è©³ç´°ãƒ‘ãƒãƒ«è¡¨ç¤º
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
  - WebSocketã§çŠ¶æ…‹åŒæœŸ
  - 1ç§’é–“éš”ã§æ›´æ–°

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¦ä»¶

- [ ] è¤‡æ•°ã®æç”»ãƒ¢ãƒ¼ãƒ‰ï¼ˆEntity/Worktree/Agentï¼‰
- [ ] VRãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
- [ ] ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆãƒ»éŒ²ç”»æ©Ÿèƒ½
- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ†ãƒ¼ãƒ

## ğŸ› ï¸ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **è¨€èª**: TypeScript
- **Framework**: React
- **3Dãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: Three.js + 3D Force Graph
- **Backend**: Rust (Axum) - WebSocketã‚µãƒ¼ãƒãƒ¼
- **ä¾å­˜**:
  - `three` - 3Dæç”»ã‚¨ãƒ³ã‚¸ãƒ³
  - `3d-force-graph` - åŠ›å­¦çš„ã‚°ãƒ©ãƒ•
  - `@react-three/fiber` - React Three.jsçµ±åˆ

## ğŸ“ è¨­è¨ˆ

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
miyabi-dashboard/
â”œâ”€â”€ package.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.tsx                  # ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ App.tsx                   # ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ EntityRelationGraph.tsx   # ERå›³3Dè¡¨ç¤º
â”‚   â”‚   â”œâ”€â”€ WorktreeGraph.tsx         # Worktreeå¯è¦–åŒ–
â”‚   â”‚   â”œâ”€â”€ AgentMonitor.tsx          # Agentç›£è¦–
â”‚   â”‚   â””â”€â”€ ControlPanel.tsx          # æ“ä½œãƒ‘ãƒãƒ«
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useWebSocket.ts           # WebSocket hook
â”‚   â”‚   â””â”€â”€ useGraphData.ts           # ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿å–å¾—
â”‚   â””â”€â”€ types/
â”‚       â”œâ”€â”€ entity.ts
â”‚       â”œâ”€â”€ worktree.ts
â”‚       â””â”€â”€ agent.ts
â””â”€â”€ backend/
    â””â”€â”€ src/
        â””â”€â”€ server.rs                 # WebSocketã‚µãƒ¼ãƒãƒ¼
```

### React + Three.jså®Ÿè£…

```typescript
// miyabi-dashboard/src/components/EntityRelationGraph.tsx

import React, { useEffect, useRef } from 'react';
import ForceGraph3D from '3d-force-graph';
import * as THREE from 'three';

interface Node {
  id: string;
  name: string;
  type: 'entity' | 'worktree' | 'agent';
  status?: 'active' | 'idle' | 'running';
  size: number;
}

interface Link {
  source: string;
  target: string;
  relation: string;
}

const EntityRelationGraph: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null);
  const graphRef = useRef<any>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // 3D Force Graphã®åˆæœŸåŒ–
    const graph = ForceGraph3D()(containerRef.current)
      .graphData({ nodes: [], links: [] })
      .nodeAutoColorBy('type')
      .nodeVal('size')
      .nodeLabel((node: any) => `${node.name} (${node.type})`)
      .nodeThreeObject((node: any) => {
        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ãƒ‰æç”»
        const sprite = new THREE.Sprite(
          new THREE.SpriteMaterial({
            color: getNodeColor(node.status),
            map: new THREE.CanvasTexture(generateNodeTexture(node)),
          })
        );
        sprite.scale.set(12, 12, 1);
        return sprite;
      })
      .linkWidth(2)
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.1)
      .onNodeClick((node: any) => {
        // ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
        console.log('Node clicked:', node);
        showNodeDetails(node);
      });

    graphRef.current = graph;

    // WebSocketã§ãƒ‡ãƒ¼ã‚¿å–å¾—
    const ws = new WebSocket('ws://localhost:8080/ws/graph');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      graph.graphData(data);
    };

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => {
      ws.close();
      graph._destructor();
    };
  }, []);

  const getNodeColor = (status?: string) => {
    switch (status) {
      case 'active':
      case 'running':
        return 0x00ff00; // ç·‘
      case 'idle':
        return 0xffff00; // é»„
      default:
        return 0x0088ff; // é’
    }
  };

  const generateNodeTexture = (node: Node) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return canvas;

    canvas.width = 128;
    canvas.height = 128;

    // ãƒãƒ¼ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆæç”»
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(node.name, 64, 70);

    return canvas;
  };

  return (
    <div className="graph-container">
      <div ref={containerRef} style={{ width: '100%', height: '100vh' }} />
    </div>
  );
};

export default EntityRelationGraph;
```

### WebSocketã‚µãƒ¼ãƒãƒ¼ï¼ˆRust + Axumï¼‰

```rust
// miyabi-dashboard/backend/src/server.rs

use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    response::IntoResponse,
    routing::get,
    Router,
};
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/ws/graph", get(ws_handler));

    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn ws_handler(ws: WebSocketUpgrade) -> impl IntoResponse {
    ws.on_upgrade(handle_socket)
}

async fn handle_socket(mut socket: WebSocket) {
    let mut interval = interval(Duration::from_secs(1));

    loop {
        interval.tick().await;

        // ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿å–å¾—
        let graph_data = get_graph_data().await;

        // JSONé€ä¿¡
        if socket.send(axum::extract::ws::Message::Text(
            serde_json::to_string(&graph_data).unwrap()
        )).await.is_err() {
            break;
        }
    }
}

async fn get_graph_data() -> GraphData {
    // TaskMetadata, WorktreeState, AgentStatusã‚’å–å¾—
    // GraphDataã«å¤‰æ›ã—ã¦è¿”ã™
    GraphData {
        nodes: vec![
            Node {
                id: "entity-1".to_string(),
                name: "Issue".to_string(),
                node_type: "entity".to_string(),
                status: Some("active".to_string()),
                size: 10.0,
            },
            // ...
        ],
        links: vec![
            Link {
                source: "entity-1".to_string(),
                target: "entity-2".to_string(),
                relation: "references".to_string(),
            },
            // ...
        ],
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct GraphData {
    nodes: Vec<Node>,
    links: Vec<Link>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Node {
    id: String,
    name: String,
    #[serde(rename = "type")]
    node_type: String,
    status: Option<String>,
    size: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct Link {
    source: String,
    target: String,
    relation: String,
}
```

### CLIã‚³ãƒãƒ³ãƒ‰

```bash
# Web Dashboardã‚’èµ·å‹•
miyabi dashboard

# ãƒ–ãƒ©ã‚¦ã‚¶ãŒè‡ªå‹•çš„ã«é–‹ã
# http://localhost:3000

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§èµ·å‹•
miyabi dashboard --daemon

# ãƒãƒ¼ãƒˆæŒ‡å®š
miyabi dashboard --port 8888
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

```typescript
// miyabi-dashboard/src/components/EntityRelationGraph.test.tsx

import { render } from '@testing-library/react';
import EntityRelationGraph from './EntityRelationGraph';

describe('EntityRelationGraph', () => {
  test('should render 3D graph', () => {
    const { container } = render(<EntityRelationGraph />);
    expect(container.querySelector('.graph-container')).toBeInTheDocument();
  });

  test('should update graph on WebSocket message', async () => {
    // WebSocketãƒ¢ãƒƒã‚¯ã§ãƒ†ã‚¹ãƒˆ
  });
});
```

## ğŸ“Š æˆåŠŸæ¡ä»¶

- [ ] `miyabi dashboard` ã§Webã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã™ã‚‹
- [ ] ãƒ–ãƒ©ã‚¦ã‚¶ã§Entity-Relationãƒ¢ãƒ‡ãƒ«ãŒ3Dè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] WorktreeçŠ¶æ…‹ãŒå¯è¦–åŒ–ã•ã‚Œã‚‹
- [ ] Agentå®Ÿè¡ŒçŠ¶æ³ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ“ä½œãŒå‹•ä½œã™ã‚‹
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹

## ğŸ”„ Dependencies

- **Depends on**: #613, #615, #616 (ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã€Worktreeç®¡ç†ã€TUIåŸºç›¤)

---

ğŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

### 3. Add tests for #621

- **ID**: `task-621-test`
- **Type**: Test
- **Assigned Agent**: CodeGenAgent
- **Priority**: 2
- **Estimated Duration**: 15 min
- **Dependencies**: task-621-impl

**Description**: Create comprehensive test coverage

### 4. Review code quality for #621

- **ID**: `task-621-review`
- **Type**: Refactor
- **Assigned Agent**: ReviewAgent
- **Priority**: 3
- **Estimated Duration**: 10 min
- **Dependencies**: task-621-test

**Description**: Run quality checks and code review

## ğŸ”„ Execution Plan (DAG Levels)

Tasks can be executed in parallel within each level:

### Level 0 (Parallel Execution)

- `task-621-analysis` - Analyze requirements for #621

### Level 1 (Parallel Execution)

- `task-621-impl` - Implement solution for #621

### Level 2 (Parallel Execution)

- `task-621-test` - Add tests for #621

### Level 3 (Parallel Execution)

- `task-621-review` - Review code quality for #621

## ğŸ“Š Dependency Graph

```mermaid
graph TD
    task_621_analysis["Analyze requirements for #621"]
    task_621_impl["Implement solution for #621"]
    task_621_test["Add tests for #621"]
    task_621_review["Review code quality for #621"]
    task_621_analysis --> task_621_impl
    task_621_impl --> task_621_test
    task_621_test --> task_621_review
```

## â±ï¸ Timeline Estimation

- **Sequential Execution**: 60 minutes (1.0 hours)
- **Parallel Execution (Critical Path)**: 10 minutes (0.2 hours)
- **Estimated Speedup**: 6.0x

---

*Generated by CoordinatorAgent on 2025-10-30 17:47:32 UTC*
